{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\: )\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"the Software Development Kit for neutral atom quantum computers <p>Bloqade is QuEra Computing's software development kit (SDK) for neutral atom quantum computers. It is designed to be a hub of embedded domain-specific languages (eDSLs) for neutral atom quantum computing. Bloqade is built on top of Kirin, the Kernel Intermediate Representation Infrastructure.</p> <p>Warning</p> <p>Bloqade is currently in the early stages of development. The APIs and features are subject to change. While we do not promise stability and backward compatibility at the moment, we will try to minimize breaking changes as much as possible. If you are concerned about the stability of the APIs, consider pin the version of Bloqade in your project.</p> <p>Info</p> <p>The old version (&lt;= 0.15) of Bloqade is still available as a sub-package <code>bloqade-analog</code>. You can keep using it via <code>bloqade.analog</code> module. For example <code>from bloqade import start</code> becomes <code>from bloqade.analog import start</code>. See Installation for more information.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install Bloqade, you can use the following command:</p> <pre><code>pip install bloqade\n</code></pre> <p>To install the extensions or extras for Bloqade and to setup the development environment, please refer to the installation guide.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with Bloqade, you can refer to the following tutorials:</p> <ul> <li>Background: Background information on neutral atom quantum computing.</li> <li>Digital quick start: A quick start guide for QASM2 and its extensions.</li> <li>Analog quick start: A quick start guide for the analog quantum computing eDSL (same as older <code>bloqade</code> versions).</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions to Bloqade. Please refer to the contribution guide for more information.</p>"},{"location":"#license","title":"License","text":"<p>Bloqade is licensed under the Apache License 2.0.</p>"},{"location":"background/","title":"Background","text":""},{"location":"background/#neutral-atom-qubits","title":"Neutral Atom Qubits","text":"<p>A key feature of a quantum computer is the ability to physically represent qubits. In neutral atom computers, the qubit is represented in the electronic state of the valence electron of Rubdidium 87. Arrays of individual atoms are held by laser tweezers, and quantum computations are executed by manipulating the electronic state of each atom using lasers and RF fields. Entanglement can be generated using the Rydberg state, which is a highly excited state that strongly interacts with adjacent atoms through a \\(R^{-6}\\) power law Van der Waals force.</p>"},{"location":"background/#analog-mode-quantum-computing","title":"Analog mode Quantum Computing","text":"<p>There are two modes of quantum computation that neutral atoms are capable of: Analog and Digital. In analog mode, the qubit is represented as in a ground state and a Rydberg state of an atom. The atoms are placed in user-specified arbitrary positions in a 2d space, and quantum computations can be enacted by driving the atoms between the ground and Rydberg state. However, adjacent atoms in the Rydberg state are always interacting, so the computation is done through a time evolution of the atoms via the Schrodinger equation</p> \\[ i \\hbar \\dfrac{\\partial}{\\partial t} | \\psi \\rangle = \\hat{\\mathcal{H}}(t) | \\psi \\rangle,  \\\\ \\] <p>Were \\(H\\) is a time-dependent \"Rydberg atom\" Hamiltonian.</p> \\[ \\frac{\\mathcal{H}(t)}{\\hbar} = \\sum_j \\frac{\\Omega_j(t)}{2} \\left( e^{i \\phi_j(t) } | g_j \\rangle  \\langle r_j | + e^{-i \\phi_j(t) } | r_j \\rangle  \\langle g_j | \\right) - \\sum_j \\Delta_j(t) \\hat{n}_j + \\sum_{j &lt; k} V_{jk} \\hat{n}_j \\hat{n}_k, \\] <p>where: \\(\\Omega_j\\), \\(\\phi_j\\), and \\(\\Delta_j\\) denote the Rabi frequency amplitude, laser phase, and the detuning of the driving laser field on atom (qubit) \\(j\\) coupling the two states  \\(| g_j \\rangle\\) (ground state) and \\(| r_j \\rangle\\) (Rydberg state); \\(\\hat{n}_j = |r_j\\rangle \\langle r_j|\\) is the number operator, and \\(V_{jk} = C_6/|\\mathbf{x}_j - \\mathbf{x}_k|^6\\) describes the Rydberg interaction (van der Waals interaction) between atoms \\(j\\) and \\(k\\) where \\(\\mathbf{x}_j\\) denotes the position of the atom \\(j\\); \\(C_6\\) is the Rydberg interaction constant that depends on the particular Rydberg state used. For Bloqade, the default \\(C_6 = 862690 \\times 2\\pi \\text{ MHz \u03bcm}^6\\) for \\(|r \\rangle = \\lvert 70S_{1/2} \\rangle\\) of the \\(^{87}\\)Rb atoms; \\(\\hbar\\) is the reduced Planck's constant.</p> <p>For a more nuanced read about the neutral atoms that Bloqade and Aquila use, refer to QuEra's qBook section on Qubits by puffing up atoms.</p> <p>You can find a brief explanation of the distinction below but for a more in-depth explanation you can refer to QuEra's qBook section on Analog vs Digital Quantum Computing. For more details on QuEra's cloud-accessible analog mode computer Aquila, please check out the Aquila whitepaper.</p>"},{"location":"background/#digital-mode","title":"Digital Mode","text":"<p>In the Digital Mode individual or multiple groups of qubits are controlled by applying gates (individual unitary operations). The digital mode qubit is represented in the two hyperfine clock ground states of the Rubidium 87 atom. These two states are extremely weakly interactive with the environment and other adjacent atoms, which leads to a very long coherence time upwards of 1 second. Single-qubit gates can be executed through a Raman laser drive coupling the two states to enact arbitrary rotations.</p> <p>Unlike Analog mode where the Rydberg state is persistent as part of the qubit encoding into the electronic states, digital mode only temporarily excites the atoms to the Rydberg state in order to interact with adjacent qubits, a process which typically takes less than ~1usec. Thus, a neutral atom entangling gate is executed by bringing multiple atoms together within the Rydberg blockade radius, and then doing some time-dependent drive between the hyperfine ground states and the Rydberg state, so that the final state returns to the hyperfine ground states. Due to the Rydberg blockade, only one atom can be in the Rydberg state at a time, which creates entanglement between the atoms. For more details see this paper on a recent demonstration of high fidelity gates.</p> <p>A unique advantage of reconfigurable neutral atom architectures is parallelism: the same laser can effect many lasers by aiming it in the same plane as the atom array. A single global Raman laser can enact the same parallel single-qubit gate on all qubits at the same time, and a single Rydberg laser (technically, two counter-propagating) can enact the same parallel multi-qubit gate on all cliques of qubits in an entangling region of the array. For more details see this paper on a recent demonstration of reconfigurable architectures. For this reason, it is important to represent quantum executions and circuits to be as parallel as possible. In our qasm2 dialect, we have extended qasm to natively include parallelism-- for example, <code>qasm2.parallel.cx(controls, targets)</code> represents a parallel CNOT gate between a list of <code>controls</code> on a list of <code>targets</code>.</p>"},{"location":"background/#reconfigurable-architectures-and-all-to-all-connectivity","title":"Reconfigurable architectures and \"all to all\" connectivity","text":"<p>A second advantage of reconfigurable neutral atom architectures is reconfigurability: atoms can be moved in parallel between sites in the array. QuEra's devices will have a zoned architecture, with distinct storage and entanglement zones and the ability to move atoms between them using a set of dynamic crossed AOD laser tweezers. This mobility can be considered as an efficient parallel swap gate, where any qubit can easily be moved to be adjacent to any other to enact entangling gates. For this reason, reconfigurable neutral atoms do not have a \"connectivity graph\" in the traditional sense-- instead, they have an \"all-to-all\" connectivity. There are still some technical constraints on this connectivity due to restrictions on the crossed AOD which we will detail when we open-source a move level dialect set in the near future.</p>"},{"location":"contrib/","title":"Contributing","text":"<p>Please see Installation for instructions on how to set up your development environment.</p>"},{"location":"contrib/#pre-commit-hooks","title":"Pre-commit hooks","text":"<p>We use <code>pre-commit</code> to run the linter checks before you commit your changes. The pre-commit hooks are installed as part of the development dependencies. You can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre> <p>This will run the linter checks before you commit your changes. If the checks fail, the commit will be rejected. Most of the following sections can be checked by the pre-commit hooks.</p>"},{"location":"contrib/#running-the-tests","title":"Running the tests","text":"<p>We use <code>pytest</code> for testing. To run the tests, simply run:</p> <pre><code>pytest\n</code></pre> <p>or for a specific test file with the <code>-s</code> flag to show the output of the program:</p> <pre><code>pytest -s tests/test_program.py\n</code></pre> <p>lots of tests contains pretty printing of the IR themselves, so it's useful to see the output.</p>"},{"location":"contrib/#code-style","title":"Code style","text":"<p>We use <code>black</code> for code formatting. Besides the linter requirements, we also require the following good-to-have practices:</p>"},{"location":"contrib/#naming","title":"Naming","text":"<ul> <li>try not to use abbreviation as names, unless it's a common abbreviation like <code>idx</code> for <code>index</code></li> <li>try not create a lot of duplicated name prefix unless the extra information is necessary when accessing the class object.</li> <li>try to use <code>snake_case</code> for naming variables and functions, and <code>CamelCase</code> for classes.</li> </ul>"},{"location":"contrib/#comments","title":"Comments","text":"<ul> <li>try not to write comments, unless it's really necessary. The code should be self-explanatory.</li> <li>if you have to write comments, try to use <code>NOTE:</code>, <code>TODO:</code> <code>FIXME:</code> tags to make it easier to search for them.</li> </ul>"},{"location":"contrib/#documentation","title":"Documentation","text":"<p>We use <code>just</code> for mangaging command line tools and scripts. It should be installed when you run <code>uv sync</code>. To build the documentation, simply run:</p> <pre><code>just doc\n</code></pre> <p>This will launch a local server to preview the documentation. You can also run <code>just doc-build</code> to build the documentation without launching the server.</p>"},{"location":"contrib/#license","title":"License","text":"<p>By contributing to this project, you agree to license your contributions under the Apache License 2.0 with LLVM Exceptions.</p>"},{"location":"install/","title":"Installation","text":"<p>Bloqade is available in PyPI and thus can be installed via <code>pip</code>. Install Bloqade using the following command:</p> <pre><code>pip install bloqade\n</code></pre> <p>Bloqade support python 3.10+.</p> <p>We strongly recommend developing your compiler project using <code>uv</code>, which is the official development environment for Bloqade. You can install <code>uv</code> using the following command:</p> Linux and macOSWindows <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>then</p> <pre><code>uv add kirin-toolchain\n</code></pre> <pre><code>powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre> <p>then</p> <pre><code>uv add kirin-toolchain\n</code></pre>"},{"location":"install/#bloqade-and-its-friends","title":"Bloqade and its friends","text":"<p>Bloqade is a Python namespace package, we officially provide several sub-packages, each of which is an eDSL for neutral atom quantum computing. The following is a list of the sub-packages in Bloqade:</p>"},{"location":"install/#bloqadeqasm2","title":"<code>bloqade.qasm2</code>","text":"<p>QASM2 and its extensions support for neutral atom quantum computing. Available via:</p> <pre><code>pip install bloqade[qasm2]\n</code></pre>"},{"location":"install/#bloqadeanalog","title":"<code>bloqade.analog</code>","text":"<p>Analog quantum computing eDSL for neutral atom quantum computing (previously <code>bloqade-python</code>). Available via:</p> <pre><code>pip install bloqade-analog\n</code></pre>"},{"location":"install/#bloqadepyqrack","title":"<code>bloqade.pyqrack</code>","text":"<p>Support of the PyQrack simulator as a runtime backend for QASM2 and extensions.</p> <pre><code>pip install bloqade-pyqrack\n</code></pre>"},{"location":"install/#bloqadeqbraid","title":"<code>bloqade.qbraid</code>","text":"<p>Support of the qBraid cloud service as a runtime backend for retrieving noise models and running circuits.</p> <pre><code>pip install bloqade[qbraid]\n</code></pre>"},{"location":"install/#bloqadestim-experimental","title":"<code>bloqade.stim</code> (Experimental)","text":"<p>STIM and its extensions support for neutral atom quantum computing. Available via:</p> <pre><code>pip install bloqade[stim]\n</code></pre>"},{"location":"install/#development","title":"Development","text":"<p>If you want to contribute to Bloqade, you can clone the repository from GitHub:</p> <pre><code>git clone https://github.com/QuEraComputing/bloqade.git\n</code></pre> <p>We use <code>uv</code> to manage the development environment, after you install <code>uv</code>, you can install the development dependencies using the following command:</p> <pre><code>uv sync\n</code></pre> <p>Our code review requires that you pass the tests and the linting checks. We recommend you to install <code>pre-commit</code> to run the checks before you commit your changes, the command line tool <code>pre-commit</code> has been installed as part of the development dependencies. You can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"manifesto/","title":"Bloqade Manifesto","text":"<p>The vision of Bloqade is to empower quantum scientists, from applications development to algorithmic co-design, to build hybrid quantum-classical programs that leverage the strength of neutral atom quantum computers and have a real chance of demonstrating quantum utility. Bloqade is built on top of Kirin, an open source compiler infrastructure designed for kernel functions and composable representations.</p>"},{"location":"manifesto/#composable-quantum-programming","title":"Composable quantum programming","text":"<p>Today Bloqade becomes a namespace package of multiple eDSLs (embedded domain-specific languages) around digital and analog quantum computation. <code>bloqade.analog</code> is the module for analog-mode neutral atom computers and includes several handy utilities ranging from building or analyzing analog programs, to emulation or executing on QuEra's cloud-accessible hardware \"Aquila\".</p> <p>Other submodules such as <code>bloqade.qasm2</code>, <code>bloqade.pyqrack</code> and <code>bloqade.stim</code> are the initial iteration to represent digital circuit execution using gate-based quantum computing on reconfigurable neutral atoms. It extends the QASM2 language to include extra annotation of circuits that is important for efficient execution, such as parallelism and global gates. As well as being able to construct quantum programs with the full convenience of typical classical programming within hardware kernels -- such as loops and control flow -- Bloqade also includes basic compiler transformation passes, emulation, and code generation.</p> <p>But Bloqade is not done with just these modules. We envision adding new modules (called \"dialects\") which help you write programs which are tuned for optimal performance in an error corrected era, and on neutral atom hardware. Stay tuned and help us build the future of quantum computing as we build out new components, such as QEC and atom moving dialects.</p>"},{"location":"manifesto/#hardware-oriented-programming-and-co-design","title":"Hardware-oriented programming and co-design","text":"<p>At its core, Bloqade strives to be the neutral atom SDK for getting the most out of today's and tomorrows' quantum hardware. It is clear that the circuit-level abstraction is not enough to program real quantum hardware; indeed, tomorrows' quantum demonstrations and applications must program at the hardware level and develop special tooling to compile higher-level abstractions to efficient implementations. We call this process \"co-design\": designing algorithms specialized to near-term hardware, with an eye on nontrivial demonstrations and scalable solutions. Ultimately, this co-design approach requires hardware-specific DSLs which explicitly represent the native executions on neutral atom hardware: in other words, Bloqade.</p>"},{"location":"manifesto/#hybrid-computing-beyond-circuits","title":"Hybrid computing beyond circuits","text":"<p>Many quantum algorithms are hybrid, requiring both classical and quantum resources to work together in a hybrid computation architecture. This could be anything from syndrome extraction and measurement-based computing to variational parameter updates in VQE methods and orbital fragmentation methods in molecular simulation. Through the use of the Kirin compiler infrastructure, Bloqade embraces this philosophy of heterogeneous compute. Kirin programs are written as (compositions of) kernels-- subroutines that are intended to run on particular hardware (such as QPUs), or orchestrated to run on heterogeneous compute (such as a real-time classical runtime plus a QPU). These subroutines-- plus the built-in hybrid representations-- enable many key primitives, such as error correction.</p> <p>Additionally, the ability to compose functions together and to use typical classical programming structures like <code>if</code> and recursion enables many simplifications in writing raw circuit executions. In fact, recursion and the ability to dynamically allocate new memory (which is not known until runtime) enables many powerful subroutines and is natively enabled with Bloqade's kernel-based representation; for example, see this implementation of a repeat-until-success program.</p>"},{"location":"manifesto/#analog-digital-logical-towards-real-quantum-utility","title":"Analog, digital, logical: towards real quantum utility","text":"<p>The first step in Bloqade was building out the analog mode SDK, designed to interface with QuEra\u2019s cloud-accessible analog-mode neutral-atom quantum computer Aquila, as well as enable analysis and scientific discovery in analog quantum computing. But the journey should not stop there: real quantum utility is error corrected and requires robust algorithmic exploration and design of quantum primitives, in-depth analysis of near-term hardware performance and benchmarking, and building pipelines and hybrid architectures that are intended not just for today\u2019s demonstrators but also for tomorrow\u2019s utility-scale hardware. By introducing the next generation of Bloqade, we hope to enable this exploration by adding in support for near-term digital and intermediate-term logical representations of hybrid quantum computations.</p>"},{"location":"manifesto/#join-us","title":"Join us!","text":"<p>If you are interested in contributing, please see the contribution page here. If you are interested in exploring more about neutral atom quantum computing, check out some analog tutorials here, and some circuit tutorials here. If you wish to work closer with QuEra, please feel free to reach out!</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/","title":"Introducing Bloqade SDK for Python","text":"<p>Greetings Neutral Atom QC experts, enthusiasts, and newcomers!</p> <p>We are excited to the Rydberg state thrilled to announce the Python version of our cutting-edge SDK, Bloqade. Originally developed in Julia, Bloqade has been a game-changer in the realm of Neutral Atom quantum computing. With the introduction of the Python version, we aim to make this revolutionary technology more accessible and user-friendly than ever before.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#why-python","title":"Why Python?","text":"<p>Python is one of the most widely used programming languages, especially in the quantum computing community and broader scientific communities. By extending Bloqade to Python, we are opening doors to a broader audience, enabling more developers, researchers, and organizations to harness the power of Neutral Atom quantum computing.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#neutral-atom-quantum-computing","title":"Neutral Atom Quantum Computing","text":"<p>Recently, the Neutral Atom platform has come on the QC scene in the form of Analog Hamiltonian Simulators that have a broad set of use cases beyond quantum circuits. Ranging from simulating unique quantum phases of matter, solving combinatorial optimization problems, and machine learning applications, the analog mode provides strong values in solving practical, interesting problems in the near term.</p> <p>These advances are crucial milestones on the way towards scalable digital gate-based architecture using atom shuttling. This new technology and its novel applications demand a paradigm shift in the way we not only think about quantum computing, but translate those ideas to real hardware. Enter Bloqade, a next-generation SDK designed to put the power of neutral atoms at your fingertips.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#why-bloqade","title":"Why Bloqade?","text":"<p>Bloqade is designed with the primary goal of making it easier to compose programs for QuEra\u2019s hardware and analyze results.</p> <p>We've gained valuable insights into how users have used our neutral-atom hardware and with it, their struggles with existing tools. We took advantage of this knowledge to produce a tool that could take the \"hard\" out of \"hardware\". Bloqade is precision-balanced in both flexibility to empower novices to experiment with ease and power to let experts perform cutting-edge work without breaking a sweat.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#highlights","title":"Highlights","text":""},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#smart-documentation","title":"Smart Documentation","text":"<p>With our commitment to enabling more seamless program development, we've put the relevant documentation you need right where and when you need it.</p> <p>No more obnoxious switching between your favorite coding environment and documentation in a separate window. Let Bloqade guide you where you'd like to go:</p> <p></p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#fully-parameterized-analog-programs","title":"Fully Parameterized Analog Programs","text":"<p>Parameter sweeps are a common theme of programs for analog quantum computers, where a user would like to observe differences in output results by varying a value or values in their program.</p> <p>You used to have to manually crank out variations of your program with different values and then keep track of all the individual submissions to the emulator and hardware, a mess to keep track of and process the results of afterwards.</p> <p>Bloqade eliminates this with its own support for variables that can later be assigned single values or a whole sequence of values for trivial parameter sweeping. This isn't some feature that's constrained to a certain backend, you can take your program with all its variables and submit it to your choice of emulator or our hardware directly.</p> <pre><code>from bloqade import var\nfrom bloqade.atom_arrangement import Square\n\nimport numpy as np\n\nadiabatic_durations = [0.4, 3.2, 0.4]\n\n# create variables explicitly...\nmax_detuning = var(\"max_detuning\")\n# ...or implicitly inside the program definition.\nadiabatic_program = (\n    Square(3, \"lattice_spacing\")\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=adiabatic_durations, values=[0.0, \"max_rabi\", \"max_rabi\", 0.0]\n    )\n    .detuning.uniform.piecewise_linear(\n        durations=adiabatic_durations,\n        values=[\n            -max_detuning, # scalar variables support direct arithmetic operations\n            -max_detuning,\n            max_detuning,\n            max_detuning,\n        ],\n    )\n    .assign(max_rabi=15.8, max_detuning=16.33)\n    .batch_assign(lattice_spacing=np.arrange(4.0, 7.0, 0.5))\n)\n\n# Launch your program on your choice of Braket or in-house emulator...\nemu_results = adiabatic_program.braket.local_emulator().run(10000)\nfaster_emu_results = adiabatic_program.bloqade.python().run(10000)\n# ...as well as hardware without stress\nhw_results = adiabatic_program.parallelize(24).braket.aquila().run_async(100)\n</code></pre>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#integrated-visualization-tools","title":"Integrated Visualization Tools","text":"<p>Instantly understand what your programs are doing faster than you can say \"neutral atoms rock!\" with Bloqade's built-in visualization tools:</p> <p></p> <p></p> <p>For your results, no more obnoxious manual compilation of results across different parameters or wrangling them into more useful forms. Get insights of experiment outcomes in the blink of an eye:</p> <p></p> <p></p> <p>Now that's what we call having your cake AND eating it.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#bloqade-roadmap","title":"Bloqade Roadmap","text":""},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#bloqade-alpha-phase","title":"Bloqade Alpha Phase","text":"<p>During the next year, we plan on continuing development of Bloqade's python interface. If you are as excited about Neutral Atom quantum computing as us, or heck, even just quantum physics in general, give Bloqade a try! This is your opportunity to influence the direction of Bloqade and get in on the ground floor of the next Quantum Computing revolution.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#but-what-about-julia","title":"But what about Julia?","text":"<p>Don't you guys already HAVE an SDK in Julia? Why do you need two SDKs?</p> <p>That's right! However, there's a key motivating factor for the reason we created Bloqade Python that's distinct for Bloqade.jl's existence.</p> <p>Bloqade.jl is primarily geared as a high-performance emulator. It allows you to design complex neutral-atom algorithms that may not necessarily run on our hardware BUT are excellent if you're exploring novel physical phenonema/algorithms or as a tool for pedagogical purposes.</p> <p>Bloqade.jl does have the ability to submit to Aquila, our flagship quantum computer, but for more complex tasks such as sweeping parameters (e.g. running the same program on hardware with slightly different parameters each time) or advanced post-processing, it becomes cumbersome quite quickly.</p> <p>There are no plans to drop support any time soon though. On the contrary, we plan on fully integrating Bloqade.jl into the Python package, which will enable you to program Neutral Atom quantum hardware without having to choose.</p> <p>We very much look forward to you trying out Bloqade!</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/","title":"A new journey for Bloqade","text":"<p>In 2023 we were excited to introduce Bloqade, a python SDK for programming and interfacing with analog mode neutral atom hardware based off feedback from our community as well as a need to make conducting experiments on our hardware easier. Today, we introduce the next generation of Bloqade: as well as programming analog-mode computation, our new bloqade module enables programming gate-based computation, with an eye on near-term NISQ demonstrations and intermediate-term fault tolerant solutions. Don\u2019t worry; all of your favorite features of the previous generation of Bloqade are still there under the <code>bloqade.analog</code> namespace, but now you can explore digital-mode computation specialized to reconfigurable neutral atom architectures. Why have we built this new module? There are plenty of incredible quantum programming packages, such as Qiskit and Cirq, as well as an entire ecosystem of middleware providers with specialized pipelines to turn abstract problems into circuits. However, these packages may not be everything that is needed for efficient hardware execution on neutral atom hardware: a circuits-only representation of quantum executions may be an insufficient abstraction for effective hardware-level programs. This is a challenge: we want to enable everyone to maximally leverage the power of neutral atom quantum computers beyond abstract circuit representations. For this reason, we are building Bloqade to be a hardware-oriented SDK to represent hybrid executions on reconfigurable neutral atom hardware. In this way, Bloqade can be integrated into the larger ecosystem\u2014for example, code generation of QASM from a Bloqade program, but be an SDK specialized to our hardware: THE SDK for neutral atoms.</p> <p>The vision of Bloqade is to empower quantum scientists, working on things ranging from applications development to algorithmic co-design, to build hybrid quantum-classical programs that leverage the strength of neutral atom quantum computers and have a real chance of demonstrating quantum utility. Bloqade is built on top of Kirin, an open source compiler infrastructure designed for kernel functions and embedded Domain-Specific Language (eDSL) creation.</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/#composable-quantum-programming","title":"Composable quantum programming","text":"<p>As of today, Bloqade has two objectives: digital and analog quantum computing. <code>bloqade-analog</code> is the SDK for analog-mode neutral atom computers and includes several handy utilities ranging from building and analyzing analog programs, to emulation and execution on QuEra's cloud-accessible hardware \"Aquila\". <code>bloqade</code> is the initial iteration to represent digital circuit execution using gate-based quantum computing on reconfigurable neutral atom architecture. It extends the QASM2 language to include extra annotation of circuits that is important for efficient execution, such as parallelism and global gates. As well as being able to construct quantum programs with the full convenience of features found in classical programming languages - such as loops, control flows and closures - <code>bloqade</code> also includes basic compiler transformation passes, emulation, and code generation.</p> <p>But <code>bloqade</code> is not done with just these two components. We envision adding new components (called \"dialects\") which help you write programs which are tuned for optimal performance in an error corrected era of neutral atom hardware. Stay tuned and help us build the future of quantum computing as we build out new components targeting QEC and atom moving!</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/#hardware-oriented-programming-and-co-design","title":"Hardware-oriented programming and co-design","text":"<p>At its core, Bloqade strives to be the neutral atom SDK for getting the most out of today's and tomorrows' quantum hardware. It is clear that the circuit-level abstraction is not enough to program real quantum hardware; indeed, tomorrows' quantum demonstrations and applications must program at the hardware level and develop special tooling to compile higher-level abstractions to efficient implementations. We call this process \"co-design\": designing algorithms specialized to near-term hardware, with an eye on nontrivial demonstrations and scalable solutions. Ultimately, this co-design approach requires hardware-specific DSLs which explicitly represent the native executions on neutral atom hardware: in other words, Bloqade.</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/#hybrid-computing-beyond-circuits","title":"Hybrid computing beyond circuits","text":"<p>Many quantum algorithms are hybrid, requiring both classical and quantum resources to work together in tandem. This could be anything from syndrome extraction and measurement-based computing to variational parameter updates in VQE methods and orbital fragmentation methods in molecular simulation. Through the use of the Kirin compiler infrastructure, Bloqade embraces this philosophy of heterogeneous compute. Kirin programs are written as (compositions of) kernels -- subroutines that are intended to run on particular hardware (such as QPUs), or orchestrated to run on heterogeneous compute (such as a real-time classical runtime plus a QPU). These subroutines -- plus the built-in hybrid representations-- enable many key primitives, such as error correction.</p> <p>Additionally, the ability to compose functions together and to use typical classical programming structures like <code>if</code> and recursions enables many simplifications in writing complex circuits. In fact, recursions and the ability to dynamically allocate new memory (which is not known until runtime) enables many powerful subroutines and is natively enabled with Bloqade's kernel-based representation; for example, see this implementation of a repeat-until-success program.</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/#analog-digital-logical-towards-real-quantum-utility","title":"Analog, digital, logical: towards real quantum utility","text":"<p>The first step in Bloqade's journey was building out the analog mode SDK, designed to interface with QuEra\u2019s cloud-accessible analog-mode neutral-atom quantum computer Aquila, as well as enable analysis and scientific discovery in analog quantum computing. But the journey should not stop there: real quantum utility is error corrected and requires robust algorithmic exploration and design of quantum primitives, in-depth analysis of near-term hardware performance and benchmarking, and building pipelines and hybrid architectures that are intended not just for today\u2019s demonstrations but also for tomorrow\u2019s utility-scale hardware. By introducing the next generation of Bloqade, we hope to enable this exploration by adding in support for near-term digital and intermediate-term logical representations of hybrid quantum computations.</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/#learn-more","title":"Learn more","text":"<p>Bloqade is an open-source project and can be freely downloaded and modified; you can learn how to do so here. If you want to see how to write programs with of the new <code>bloqade</code> package, check out our examples here. If you would like to learn more about QuEra Computing Inc., check out our webpage as well as discover our many academic publications and demonstrations.</p>"},{"location":"digital/","title":"Index","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"digital/#digital-bloqade","title":"Digital Bloqade","text":"<p>This page provides a collection of quick examples to help you get started with Digital Bloqade. Each example is a self-contained page that demonstrates a specific feature or use case. You can copy and paste the code snippets into your own project and modify them as needed.</p> <p>You can also find the corresponding scripts in jupytext format at the bloqade repository under <code>docs/digital/examples/</code>.</p>"},{"location":"digital/examples/ghz/","title":"GHZ State Preparation with Parallelism","text":"In\u00a0[\u00a0]: Copied! <pre>import math\n\nfrom kirin.dialects import ilist\n\nfrom bloqade import qasm2\n</pre> import math  from kirin.dialects import ilist  from bloqade import qasm2 In\u00a0[\u00a0]: Copied! <pre>def ghz_linear(n: int):\n    n_qubits = int(2**n)\n\n    @qasm2.extended\n    def ghz_linear_program():\n\n        qreg = qasm2.qreg(n_qubits)\n        # Apply a Hadamard on the first qubit\n        qasm2.h(qreg[0])\n        # Create a cascading sequence of CX gates\n        # necessary for quantum computers that\n        # only have nearest-neighbor connectivity between qubits\n        for i in range(1, n_qubits):\n            qasm2.cx(qreg[i - 1], qreg[i])\n\n    return ghz_linear_program\n</pre> def ghz_linear(n: int):     n_qubits = int(2**n)      @qasm2.extended     def ghz_linear_program():          qreg = qasm2.qreg(n_qubits)         # Apply a Hadamard on the first qubit         qasm2.h(qreg[0])         # Create a cascading sequence of CX gates         # necessary for quantum computers that         # only have nearest-neighbor connectivity between qubits         for i in range(1, n_qubits):             qasm2.cx(qreg[i - 1], qreg[i])      return ghz_linear_program <p>Circuit vs. Execution Depth</p> <p> Before going any further, it's worth distinguishing between the concept of circuit depth and circuit execution depth. For example, in the following implementation, each CX gate instruction inside the for-loop is executed in sequence. So even thought the circuit depth is $log(N) = n$, the circuit execution depth is still $N$. </p> In\u00a0[\u00a0]: Copied! <pre>def ghz_log_depth(n: int):\n    n_qubits = int(2**n)\n\n    @qasm2.extended\n    def layer_of_cx(i_layer: int, qreg: qasm2.QReg):\n        step = n_qubits // (2**i_layer)\n        for j in range(0, n_qubits, step):\n            qasm2.cx(ctrl=qreg[j], qarg=qreg[j + step // 2])\n\n    @qasm2.extended\n    def ghz_log_depth_program():\n\n        qreg = qasm2.qreg(n_qubits)\n\n        qasm2.h(qreg[0])\n        for i in range(n):\n            layer_of_cx(i_layer=i, qreg=qreg)\n\n    return ghz_log_depth_program\n</pre> def ghz_log_depth(n: int):     n_qubits = int(2**n)      @qasm2.extended     def layer_of_cx(i_layer: int, qreg: qasm2.QReg):         step = n_qubits // (2**i_layer)         for j in range(0, n_qubits, step):             qasm2.cx(ctrl=qreg[j], qarg=qreg[j + step // 2])      @qasm2.extended     def ghz_log_depth_program():          qreg = qasm2.qreg(n_qubits)          qasm2.h(qreg[0])         for i in range(n):             layer_of_cx(i_layer=i, qreg=qreg)      return ghz_log_depth_program In\u00a0[\u00a0]: Copied! <pre>def ghz_log_simd(n: int):\n    n_qubits = int(2**n)\n\n    @qasm2.extended\n    def layer(i_layer: int, qreg: qasm2.QReg):\n        step = n_qubits // (2**i_layer)\n\n        def get_qubit(x: int):\n            return qreg[x]\n\n        ctrl_qubits = ilist.Map(fn=get_qubit, collection=range(0, n_qubits, step))\n        targ_qubits = ilist.Map(\n            fn=get_qubit, collection=range(step // 2, n_qubits, step)\n        )\n\n        # Ry(-pi/2)\n        qasm2.parallel.u(qargs=targ_qubits, theta=-math.pi / 2, phi=0.0, lam=0.0)\n\n        # CZ gates\n        qasm2.parallel.cz(ctrls=ctrl_qubits, qargs=targ_qubits)\n\n        # Ry(pi/2)\n        qasm2.parallel.u(qargs=targ_qubits, theta=math.pi / 2, phi=0.0, lam=0.0)\n\n    @qasm2.extended\n    def ghz_log_depth_program():\n\n        qreg = qasm2.qreg(n_qubits)\n\n        qasm2.h(qreg[0])\n        for i in range(n):\n            layer(i_layer=i, qreg=qreg)\n\n    return ghz_log_depth_program\n</pre> def ghz_log_simd(n: int):     n_qubits = int(2**n)      @qasm2.extended     def layer(i_layer: int, qreg: qasm2.QReg):         step = n_qubits // (2**i_layer)          def get_qubit(x: int):             return qreg[x]          ctrl_qubits = ilist.Map(fn=get_qubit, collection=range(0, n_qubits, step))         targ_qubits = ilist.Map(             fn=get_qubit, collection=range(step // 2, n_qubits, step)         )          # Ry(-pi/2)         qasm2.parallel.u(qargs=targ_qubits, theta=-math.pi / 2, phi=0.0, lam=0.0)          # CZ gates         qasm2.parallel.cz(ctrls=ctrl_qubits, qargs=targ_qubits)          # Ry(pi/2)         qasm2.parallel.u(qargs=targ_qubits, theta=math.pi / 2, phi=0.0, lam=0.0)      @qasm2.extended     def ghz_log_depth_program():          qreg = qasm2.qreg(n_qubits)          qasm2.h(qreg[0])         for i in range(n):             layer(i_layer=i, qreg=qreg)      return ghz_log_depth_program <p>Using Closures to Capture Global Variables</p> <p> While bloqade.qasm2 permits a main program with arguments, standard QASM2 does not. To get around this, we need to put the program in a closure. Our Kirin compiler toolchain can capture the global variable inside the closure. In this case, the n_qubits will be captured upon calling the ghz_log_simd(n_qubits) python function. As a result, the returned QASM2 program will not have any arguments. </p> In\u00a0[\u00a0]: Copied! <pre>target = qasm2.emit.QASM2(\n    allow_parallel=True,\n)\nast = target.emit(ghz_log_simd(4))\nqasm2.parse.pprint(ast)\n</pre> target = qasm2.emit.QASM2(     allow_parallel=True, ) ast = target.emit(ghz_log_simd(4)) qasm2.parse.pprint(ast)"},{"location":"digital/examples/ghz/#ghz-state-preparation-with-parallelism","title":"GHZ State Preparation with Parallelism\u00b6","text":"<p>In this example, we will implement a Greenberger-Horne-Zeilinger (GHZ) state preparation circuit with $N = 2^n$ qubits.</p> <p>First, we will present the standard linear-depth construction in Bloqade but later we will present a log-depth construction that achieves the same result. We then take this one step further and use the fact that Bloqade (and QuEra's neutral atom hardware!) support parallel gates, allowing for the application of the same gate across multiple qubits simultaneously. Combined with the fact that atom shuttling allows for arbitrary connectivity, we can also decrease the circuit execution depth from $N$ to just $n$.</p>"},{"location":"digital/examples/ghz/#simple-linear-depth-implementation-of-a-ghz-state-preparation-circuit","title":"Simple Linear Depth Implementation of a GHZ State Preparation Circuit\u00b6","text":"<p>A simple GHZ state preparation circuit can be built with $N - 1$ CX gates and $1$ H gate. This gives the circuit an execution depth of $N$.</p>"},{"location":"digital/examples/ghz/#log-depth-implementation-of-a-ghz-state-preparation-circuit","title":"Log-depth Implementation of a GHZ State Preparation Circuit\u00b6","text":"<p>Let's take a look how we can rewrite the circuit to take advantage of QuEra's hardware capabilities. We can achieve log(N) circuit depth by rearranging the CX gates (see Mooney, White, Hill, Hollenberg - 2021).</p>"},{"location":"digital/examples/ghz/#our-native-gate-set-and-parallelism","title":"Our Native Gate Set and Parallelism\u00b6","text":"<p>By nature, our digital quantum computer can execute native gates in parallel in an single instruction/ execution cycle. The concept is very similar to the SIMD (Single Instruction, Multiple Data) in classical computing.</p> <p>On our hardware, there are two important factors to be considered:</p> <ol> <li>the native gate set allows for arbitrary (parallel) rotations and (parallel) CZ gates.</li> <li>Our atom shuttling architecture allows arbitrary qubit connectivity. This means that our parallel instruction is not limited to fixed connectivity (for example nearest neighbor connectivity).</li> </ol> <p>With this in mind, we can rewrite the <code>layer</code> subroutine to now use the <code>qasm2.parallel</code> dialect in Bloqade. We know that the CX gate can be decomposed into a CZ gate with two single-qubit gates $R_y(-\\pi/2)$ and $R_y(\\pi/2)$ acting on the target qubits. With this decomposition in mind, we can now using our parallel gate instructions <code>parallel.u</code> and <code>parallel.cz</code>. With the following modification, we can further reduce the circuit execution depth to just $n$ (log of the total number of qubits $N$)</p>"},{"location":"digital/examples/pauli_exponentiation/","title":"Pauli Exponentiation for Quantum Simulation","text":"In\u00a0[\u00a0]: Copied! <pre>import math\n\nfrom bloqade import qasm2\n</pre> import math  from bloqade import qasm2 <p>First, we define the <code>zzzz_gadget</code> function which is a simple implementation of Pauli Z exponentiation with a parameterized angle <code>gamma</code>.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef zzzz_gadget(targets: tuple[qasm2.Qubit, ...], gamma: float):\n    for i in range(len(targets) - 1):\n        qasm2.cx(targets[i], targets[i + 1])\n\n    qasm2.rz(targets[-1], gamma)\n\n    for j in range(len(targets) - 1):\n        qasm2.cx(targets[-j - 1], targets[-j - 2])\n</pre> @qasm2.extended def zzzz_gadget(targets: tuple[qasm2.Qubit, ...], gamma: float):     for i in range(len(targets) - 1):         qasm2.cx(targets[i], targets[i + 1])      qasm2.rz(targets[-1], gamma)      for j in range(len(targets) - 1):         qasm2.cx(targets[-j - 1], targets[-j - 2]) <p>Next, we define the <code>pauli_basis_change</code> function which is a simple implementation of Pauli basis change with a parameterized start and end Pauli basis.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef pauli_basis_change(targets: tuple[qasm2.Qubit, ...], start: str, end: str):\n    # assert len(targets) == len(start)\n    # assert len(targets) == len(end)\n\n    # for qubit, start_pauli, end_pauli in zip(targets, start, end):\n    for i in range(len(targets)):\n        qubit = targets[i]\n        start_pauli = start[i]\n        end_pauli = end[i]\n\n        target = start_pauli + end_pauli\n        if target == \"ZX\":\n            qasm2.ry(qubit, math.pi / 2)\n        elif target == \"ZY\":\n            qasm2.rx(qubit, -math.pi / 2)\n        # elif target == \"ZZ\":\n        #     pass\n        # elif target == \"XX\":\n        #     pass\n        elif target == \"XY\":\n            qasm2.rz(qubit, math.pi / 2)\n        elif target == \"XZ\":\n            qasm2.ry(qubit, -math.pi / 2)\n        elif target == \"YX\":\n            qasm2.rz(qubit, -math.pi / 2)\n        # elif target == \"YY\":\n        #     pass\n        elif target == \"YZ\":\n            qasm2.rx(qubit, math.pi / 2)\n</pre> @qasm2.extended def pauli_basis_change(targets: tuple[qasm2.Qubit, ...], start: str, end: str):     # assert len(targets) == len(start)     # assert len(targets) == len(end)      # for qubit, start_pauli, end_pauli in zip(targets, start, end):     for i in range(len(targets)):         qubit = targets[i]         start_pauli = start[i]         end_pauli = end[i]          target = start_pauli + end_pauli         if target == \"ZX\":             qasm2.ry(qubit, math.pi / 2)         elif target == \"ZY\":             qasm2.rx(qubit, -math.pi / 2)         # elif target == \"ZZ\":         #     pass         # elif target == \"XX\":         #     pass         elif target == \"XY\":             qasm2.rz(qubit, math.pi / 2)         elif target == \"XZ\":             qasm2.ry(qubit, -math.pi / 2)         elif target == \"YX\":             qasm2.rz(qubit, -math.pi / 2)         # elif target == \"YY\":         #     pass         elif target == \"YZ\":             qasm2.rx(qubit, math.pi / 2) <p>Putting it all together, we define the <code>pauli_exponential</code> function which is a simple implementation of Pauli Exponentiation with a parameterized Pauli basis and angle <code>gamma</code>.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef pauli_exponential(targets: tuple[qasm2.Qubit, ...], pauli: str, gamma: float):\n    # assert len(targets) == len(pauli)\n\n    pauli_basis_change(targets=targets, start=\"Z\" * len(targets), end=pauli)\n    zzzz_gadget(targets=targets, gamma=gamma)\n    pauli_basis_change(targets=targets, start=pauli, end=\"Z\" * len(targets))\n</pre> @qasm2.extended def pauli_exponential(targets: tuple[qasm2.Qubit, ...], pauli: str, gamma: float):     # assert len(targets) == len(pauli)      pauli_basis_change(targets=targets, start=\"Z\" * len(targets), end=pauli)     zzzz_gadget(targets=targets, gamma=gamma)     pauli_basis_change(targets=targets, start=pauli, end=\"Z\" * len(targets)) <p>Finally, we define the <code>main</code> function as the entry point of the program.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef main():\n    register = qasm2.qreg(4)\n    pauli_exponential((register[0], register[1], register[2]), \"ZXY\", 0.5)\n</pre> @qasm2.extended def main():     register = qasm2.qreg(4)     pauli_exponential((register[0], register[1], register[2]), \"ZXY\", 0.5) <p>we can now ask the compiler to emit the QASM2 code for the <code>main</code> function.</p> In\u00a0[\u00a0]: Copied! <pre>target = qasm2.emit.QASM2()\nast = target.emit(main)\nqasm2.parse.pprint(ast)\n</pre> target = qasm2.emit.QASM2() ast = target.emit(main) qasm2.parse.pprint(ast)"},{"location":"digital/examples/pauli_exponentiation/#pauli-exponentiation-for-quantum-simulation","title":"Pauli Exponentiation for Quantum Simulation\u00b6","text":"<p>In this example, we will consider a simple Pauli Exponentiation circuit.</p>"},{"location":"digital/examples/qaoa/","title":"QAOA","text":"<p>Lets do a simple example of a prototype circuit that benefits from parallelism: QAOA solving the MaxCut problem. For more details, see arXiv:1411.4028 and the considerable literature that has developed around this algorithm.</p> In\u00a0[\u00a0]: Copied! <pre>import math\nfrom typing import Any\n\nimport kirin\nimport networkx as nx\nfrom kirin.dialects import py, ilist\n\nfrom bloqade import qasm2\n\npi = math.pi\n</pre> import math from typing import Any  import kirin import networkx as nx from kirin.dialects import py, ilist  from bloqade import qasm2  pi = math.pi <p>MaxCut is a combinatorial graph problem that seeks to bi-partition the nodes of some graph G such that the number of edges between the two partitions is maximized. Here, we choose a random 3 regular graph with 32 nodes ref</p> In\u00a0[\u00a0]: Copied! <pre>N = 32\nG = nx.random_regular_graph(3, N, seed=42)\n</pre> N = 32 G = nx.random_regular_graph(3, N, seed=42) <p>To build the quantum program, we use a builder function and use closure to pass variables inside of the kernel function (kirin methods). In this case, the two variables that are passed inside are the edges and nodes of the graph.</p> <p>The QAOA first prepares the |+&gt; state as a superposition of all possible bitstrings, then repeats between the (diagonal) cost function and the mixer X with angles gamma and beta. It is parameterized by gamma and betas, which are each the p length lists of angles.</p> <p>Lets first implement the sequential version of the QAOA algorithm, which does not inform any parallelism to the compiler.</p> In\u00a0[\u00a0]: Copied! <pre>def qaoa_sequential(G: nx.Graph) -&gt; kirin.ir.Method:\n\n    edges = list(G.edges)\n    nodes = list(G.nodes)\n    N = len(nodes)\n\n    @qasm2.extended\n    def kernel(gamma: ilist.IList[float, Any], beta: ilist.IList[float, Any]):\n        # Initialize the register in the |+&gt; state\n        qreg = qasm2.qreg(N)\n        for i in range(N):  # structural control flow is native to the Kirin compiler\n            qasm2.h(qreg[i])\n\n        # Repeat the cost and mixer layers\n        for i in range(len(gamma)):\n            # The cost layer, which corresponds to a ZZ(phase) gate applied\n            # to each edge of the graph\n            for j in range(len(edges)):\n                edge = edges[j]\n                qasm2.cx(qreg[edge[0]], qreg[edge[1]])\n                qasm2.rz(qreg[edge[1]], gamma[i])\n                qasm2.cx(qreg[edge[0]], qreg[edge[1]])\n            # The mixer layer, which corresponds to a X(phase) gate applied\n            # to each node of the graph\n            for j in range(N):\n                qasm2.rx(qreg[j], beta[i])\n\n        return qreg\n\n    return kernel\n</pre> def qaoa_sequential(G: nx.Graph) -&gt; kirin.ir.Method:      edges = list(G.edges)     nodes = list(G.nodes)     N = len(nodes)      @qasm2.extended     def kernel(gamma: ilist.IList[float, Any], beta: ilist.IList[float, Any]):         # Initialize the register in the |+&gt; state         qreg = qasm2.qreg(N)         for i in range(N):  # structural control flow is native to the Kirin compiler             qasm2.h(qreg[i])          # Repeat the cost and mixer layers         for i in range(len(gamma)):             # The cost layer, which corresponds to a ZZ(phase) gate applied             # to each edge of the graph             for j in range(len(edges)):                 edge = edges[j]                 qasm2.cx(qreg[edge[0]], qreg[edge[1]])                 qasm2.rz(qreg[edge[1]], gamma[i])                 qasm2.cx(qreg[edge[0]], qreg[edge[1]])             # The mixer layer, which corresponds to a X(phase) gate applied             # to each node of the graph             for j in range(N):                 qasm2.rx(qreg[j], beta[i])          return qreg      return kernel <p>Next, lets implement a SIMD (Single Instruction, Multiple Data) version of the QAOA algorithm, which effectively represents the parallelism in the QAOA algorithm. This can be done by coloring the (commuting) ZZ(phase) gates into groups with non-overlapping sets of qubits, and then applying each of those groups in parallel. By Vizing's theorem the edges of a graph can efficiently be colored into $\\Delta+1$ colors, where $\\Delta$ is the maximum degree of the graph. Unfortunately, networkx does not have a native implementation of the algorithm so instead we use the lesser [Brooks' theorem]https://en.wikipedia.org/wiki/Brooks%27_theorem) to color the edges using an equitable coloring of the line graph.</p> In\u00a0[\u00a0]: Copied! <pre>def qaoa_simd(G: nx.Graph) -&gt; kirin.ir.Method:\n\n    nodes = list(G.nodes)\n\n    # Note that graph computation is happening /outside/ the kernel function:\n    # this is a computation that occurs on your laptop in Python when you generate\n    # a program, as opposed to on a piece of quantum hardware, which is what\n    # occurs inside of the kernel.\n    Gline = nx.line_graph(G)\n    colors = nx.algorithms.coloring.equitable_color(Gline, num_colors=5)\n    left_ids = ilist.IList(\n        [\n            ilist.IList([edge[0] for edge in G.edges if colors[edge] == i])\n            for i in range(5)\n        ]\n    )\n    right_ids = ilist.IList(\n        [\n            ilist.IList([edge[1] for edge in G.edges if colors[edge] == i])\n            for i in range(5)\n        ]\n    )\n    # We can use composition of kernel functions to simplify repeated code.\n    # Small snippets (say, the CX gate) can be written once and then called\n    # many times.\n\n    @qasm2.extended\n    def parallel_h(qargs: ilist.IList[qasm2.Qubit, Any]):\n        qasm2.parallel.u(qargs=qargs, theta=pi / 2, phi=0.0, lam=pi)\n\n    # A parallel CX gate is equivalently a parallel H gate, followed by a parallel CZ gate,\n    # followed by another parallel H. the CZ can be done in any order as they permute.\n    @qasm2.extended\n    def parallel_cx(\n        ctrls: ilist.IList[qasm2.Qubit, Any], qargs: ilist.IList[qasm2.Qubit, Any]\n    ):\n        parallel_h(qargs)\n        qasm2.parallel.cz(ctrls, qargs)\n        parallel_h(qargs)\n\n    @qasm2.extended\n    def parallel_cz_phase(\n        ctrls: ilist.IList[qasm2.Qubit, Any],\n        qargs: ilist.IList[qasm2.Qubit, Any],\n        gamma: float,\n    ):\n        parallel_cx(ctrls, qargs)\n        qasm2.parallel.rz(qargs, gamma)\n        parallel_cx(ctrls, qargs)\n\n    @qasm2.extended\n    def kernel(gamma: ilist.IList[float, Any], beta: ilist.IList[float, Any]):\n        # Declare the register and set it to the |+&gt; state\n        qreg = qasm2.qreg(len(nodes))\n        # qasm2.glob.u(theta=pi / 2, phi=0.0, lam=pi,registers=[qreg])\n\n        def get_qubit(x: int):\n            return qreg[x]\n\n        all_qubits = ilist.map(fn=get_qubit, collection=range(N))\n\n        parallel_h(all_qubits)\n\n        for i in range(len(gamma)):  # For each QAOA layer...\n            # Do the ZZ phase gates...\n            for cind in range(\n                5\n            ):  # by applying a parallel CZ phase gate in parallel for each color,\n                ctrls = ilist.map(fn=get_qubit, collection=left_ids[cind])\n                qargs = ilist.map(fn=get_qubit, collection=right_ids[cind])\n                parallel_cz_phase(ctrls, qargs, gamma[i])\n            # ...then, do an X phase gate. Observe that because this happens on every\n            # qubit, we can do a global rotation, which is higher fidelity than\n            # parallel local rotations.\n            # qasm2.glob.u(theta=beta[i],phi=0.0,lam=0.0,registers=[qreg])\n            qasm2.parallel.u(qargs=all_qubits, theta=beta[i], phi=0.0, lam=0.0)\n\n        return qreg\n\n    return kernel\n</pre> def qaoa_simd(G: nx.Graph) -&gt; kirin.ir.Method:      nodes = list(G.nodes)      # Note that graph computation is happening /outside/ the kernel function:     # this is a computation that occurs on your laptop in Python when you generate     # a program, as opposed to on a piece of quantum hardware, which is what     # occurs inside of the kernel.     Gline = nx.line_graph(G)     colors = nx.algorithms.coloring.equitable_color(Gline, num_colors=5)     left_ids = ilist.IList(         [             ilist.IList([edge[0] for edge in G.edges if colors[edge] == i])             for i in range(5)         ]     )     right_ids = ilist.IList(         [             ilist.IList([edge[1] for edge in G.edges if colors[edge] == i])             for i in range(5)         ]     )     # We can use composition of kernel functions to simplify repeated code.     # Small snippets (say, the CX gate) can be written once and then called     # many times.      @qasm2.extended     def parallel_h(qargs: ilist.IList[qasm2.Qubit, Any]):         qasm2.parallel.u(qargs=qargs, theta=pi / 2, phi=0.0, lam=pi)      # A parallel CX gate is equivalently a parallel H gate, followed by a parallel CZ gate,     # followed by another parallel H. the CZ can be done in any order as they permute.     @qasm2.extended     def parallel_cx(         ctrls: ilist.IList[qasm2.Qubit, Any], qargs: ilist.IList[qasm2.Qubit, Any]     ):         parallel_h(qargs)         qasm2.parallel.cz(ctrls, qargs)         parallel_h(qargs)      @qasm2.extended     def parallel_cz_phase(         ctrls: ilist.IList[qasm2.Qubit, Any],         qargs: ilist.IList[qasm2.Qubit, Any],         gamma: float,     ):         parallel_cx(ctrls, qargs)         qasm2.parallel.rz(qargs, gamma)         parallel_cx(ctrls, qargs)      @qasm2.extended     def kernel(gamma: ilist.IList[float, Any], beta: ilist.IList[float, Any]):         # Declare the register and set it to the |+&gt; state         qreg = qasm2.qreg(len(nodes))         # qasm2.glob.u(theta=pi / 2, phi=0.0, lam=pi,registers=[qreg])          def get_qubit(x: int):             return qreg[x]          all_qubits = ilist.map(fn=get_qubit, collection=range(N))          parallel_h(all_qubits)          for i in range(len(gamma)):  # For each QAOA layer...             # Do the ZZ phase gates...             for cind in range(                 5             ):  # by applying a parallel CZ phase gate in parallel for each color,                 ctrls = ilist.map(fn=get_qubit, collection=left_ids[cind])                 qargs = ilist.map(fn=get_qubit, collection=right_ids[cind])                 parallel_cz_phase(ctrls, qargs, gamma[i])             # ...then, do an X phase gate. Observe that because this happens on every             # qubit, we can do a global rotation, which is higher fidelity than             # parallel local rotations.             # qasm2.glob.u(theta=beta[i],phi=0.0,lam=0.0,registers=[qreg])             qasm2.parallel.u(qargs=all_qubits, theta=beta[i], phi=0.0, lam=0.0)          return qreg      return kernel In\u00a0[\u00a0]: Copied! <pre>print(\"--- Sequential ---\")\nqaoa_sequential(G).code.print()\n</pre> print(\"--- Sequential ---\") qaoa_sequential(G).code.print() In\u00a0[\u00a0]: Copied! <pre>kernel = qaoa_simd(G)\n\nprint(\"\\n\\n--- Simd ---\")\nkernel.print()\n</pre> kernel = qaoa_simd(G)  print(\"\\n\\n--- Simd ---\") kernel.print() In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef main():\n    kernel([0.1, 0.2], [0.3, 0.4])\n</pre> @qasm2.extended def main():     kernel([0.1, 0.2], [0.3, 0.4]) In\u00a0[\u00a0]: Copied! <pre>target = qasm2.emit.QASM2(\n    main_target=qasm2.main.union(\n        [qasm2.dialects.parallel, qasm2.dialects.glob, ilist, py.constant]\n    )\n)\nast = target.emit(main)\nqasm2.parse.pprint(ast)\n</pre> target = qasm2.emit.QASM2(     main_target=qasm2.main.union(         [qasm2.dialects.parallel, qasm2.dialects.glob, ilist, py.constant]     ) ) ast = target.emit(main) qasm2.parse.pprint(ast)"},{"location":"digital/examples/qft/","title":"Quantum Fourier Transform","text":"In\u00a0[\u00a0]: Copied! <pre>import math\n\nfrom bloqade import qasm2\nfrom bloqade.pyqrack import PyQrack\n</pre> import math  from bloqade import qasm2 from bloqade.pyqrack import PyQrack <p>In the following, we will define the Quantum Fourier Transform (QFT) circuit using recursion inside a kernel function <code>qft</code>. The <code>qft</code> function takes two arguments: a quantum register <code>qreg</code> and an integer <code>n</code> representing the number of qubits we want to apply the QFT circuit to.</p> In\u00a0[\u00a0]: Copied! <pre>pi = math.pi\n\n\n@qasm2.extended\ndef qft(qreg: qasm2.QReg, n: int, k: int):\n    if k == n:\n        return qreg\n\n    qasm2.h(qreg[k])\n    for i in range(k + 1, n):\n        qasm2.cu1(qreg[i], qreg[k], 2 * math.pi / 2**i)\n    qft(qreg, n, k + 1)  # recursion\n    return qreg\n</pre> pi = math.pi   @qasm2.extended def qft(qreg: qasm2.QReg, n: int, k: int):     if k == n:         return qreg      qasm2.h(qreg[k])     for i in range(k + 1, n):         qasm2.cu1(qreg[i], qreg[k], 2 * math.pi / 2**i)     qft(qreg, n, k + 1)  # recursion     return qreg <p>Next, we will call this kernel function <code>qft</code> inside a <code>main</code> function to check if the QFT circuit is correctly implemented. We will use a quantum register of size 3.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef main():\n    return qft(qasm2.qreg(3), 3, 0)\n</pre> @qasm2.extended def main():     return qft(qasm2.qreg(3), 3, 0) <p>Finally, we will run the <code>main</code> function on the <code>PyQrack</code> backend and print the quantum register to see the final state of the qubits after applying the QFT circuit.</p> In\u00a0[\u00a0]: Copied! <pre>device = PyQrack()\nqreg = device.run(main)\nprint(qreg)\n</pre> device = PyQrack() qreg = device.run(main) print(qreg) <p>we can also emit the QASM2 code for the <code>main</code> function and print it to see the QASM2 code that corresponds to the QFT circuit.</p> In\u00a0[\u00a0]: Copied! <pre>from bloqade.qasm2.emit import QASM2  # noqa: E402\nfrom bloqade.qasm2.parse import pprint  # noqa: E402\n\ntarget = QASM2()\nast = target.emit(main)\npprint(ast)\n</pre> from bloqade.qasm2.emit import QASM2  # noqa: E402 from bloqade.qasm2.parse import pprint  # noqa: E402  target = QASM2() ast = target.emit(main) pprint(ast)"},{"location":"digital/examples/qft/#quantum-fourier-transform","title":"Quantum Fourier Transform\u00b6","text":"<p>In this example, we will explore the Quantum Fourier Transform (QFT) circuit using recursion and iteration -- a convenient way to implement the QFT circuit using our high-level programming features.</p> <p>To begin, we will import the <code>qasm2</code> module from the <code>bloqade</code> package and the <code>PyQrack</code> backend from the <code>bloqade.pyqrack</code> module, which can be installed via</p> <pre>pip install bloqade-pyqrack[backend]\n</pre> <p>with the <code>backend</code> being one of <code> pyqrack</code>, <code>pyqrack-cpu</code>, <code>pyqrack-cuda</code> depending on the hardware and OS you have. see README for mote details.</p>"},{"location":"digital/examples/repeat_until_success/","title":"Repeat Until Success with STAR Gadget","text":"In\u00a0[\u00a0]: Copied! <pre>from bloqade import qasm2\n</pre> from bloqade import qasm2 <p>This example highlights a few interesting capabilities of having a full kernel structure with runtime control flow. One example is the ability to dynamically allocate qubits, possibly based on previous run-time measurement outcomes.</p> <p>In this case, we prepare a resource state, which is a generalization of the T state with an arbitrary Z rotation $|0\\rangle + e^{i\\theta}|1\\rangle$.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef prep_resource_state(theta: float):\n    qreg = qasm2.qreg(1)\n    qubit = qreg[0]\n    qasm2.h(qubit)\n    qasm2.rz(qubit, theta)\n    return qubit\n</pre> @qasm2.extended def prep_resource_state(theta: float):     qreg = qasm2.qreg(1)     qubit = qreg[0]     qasm2.h(qubit)     qasm2.rz(qubit, theta)     return qubit <p>Using this resource state, we can teleport the Z phase gate to a target qubit using only Clifford gates, which are much easier to implement fault-tolerantly. This is implemented by first applying a CNOT gate controlled by the resource state on the target qubit, then measuring the target qubit in the computational basis. If the measurement outcome is 1 (which occurs with 50% probability), the gadget executed a Z(theta) gate on the target qubit and teleported it to the new resource state.</p> <p>However, if the measurement outcome is 0 (which occurs with 50% probability), we apply an X gate, and the gadget executed a Z(-theta) gate on the target qubit. In order to correct this gate, we must apply a Z(+2theta) gate on the new target state. Of course, we can apply this Z(+2theta) gate by applying the same gadget with twice the angle, and repeat until we get the correct outcome.</p> <p>The simplest way to implement the gadget is to simply post-select the correct measurement outcome using an assert statement. This is straightforward, but comes with an exponential overhead in the number of resource states: there is a 50% chance of success at each step, so there is only a $2^{-n}$ chance of success after $n$ Z phase gates.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef z_phase_gate_postselect(target: qasm2.Qubit, theta: float) -&gt; qasm2.Qubit:\n    ancilla = prep_resource_state(theta)\n    qasm2.cx(ancilla, target)\n    creg = qasm2.creg(1)\n    qasm2.measure(target, creg[0])\n    if creg[0] == 1:\n        qasm2.x(ancilla)\n    return ancilla\n</pre> @qasm2.extended def z_phase_gate_postselect(target: qasm2.Qubit, theta: float) -&gt; qasm2.Qubit:     ancilla = prep_resource_state(theta)     qasm2.cx(ancilla, target)     creg = qasm2.creg(1)     qasm2.measure(target, creg[0])     if creg[0] == 1:         qasm2.x(ancilla)     return ancilla <p>To (deterministically) implement the gate, we can recursively apply the gadget by correcting the angle of the Z gate by applying Z(+2*theta). Observe that, while it is efficient to represent this as a composition of kernels, there is no equivalent representation as a circuit, as the number of resource qubits and total number of gates is not known until runtime.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef z_phase_gate_recursive(target: qasm2.Qubit, theta: float) -&gt; qasm2.Qubit:\n    \"\"\"\n    https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337 Fig. 7\n    \"\"\"\n    ancilla = prep_resource_state(theta)\n    qasm2.cx(ancilla, target)\n    creg = qasm2.creg(1)\n    qasm2.measure(target, creg[0])\n    if creg[0] == 0:\n        return z_phase_gate_recursive(ancilla, 2 * theta)\n    if creg[0] == 1:\n        qasm2.x(ancilla)\n    return ancilla\n</pre> @qasm2.extended def z_phase_gate_recursive(target: qasm2.Qubit, theta: float) -&gt; qasm2.Qubit:     \"\"\"     https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337 Fig. 7     \"\"\"     ancilla = prep_resource_state(theta)     qasm2.cx(ancilla, target)     creg = qasm2.creg(1)     qasm2.measure(target, creg[0])     if creg[0] == 0:         return z_phase_gate_recursive(ancilla, 2 * theta)     if creg[0] == 1:         qasm2.x(ancilla)     return ancilla <p>An alternative representation uses control flow to implement the same gate. If the number of repeats is fixed, this can be represented as a static circuit, though it would require a large number of resource qubits and may still fail with a small probability $2^{-attempts}$.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef z_phase_gate_loop(target: qasm2.Qubit, theta: float, attempts: int):\n    \"\"\"\n    https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337 Fig. 7\n    \"\"\"\n    creg = qasm2.creg(1)  # Implicitly initialized to 0, thanks qasm...\n    for ctr in range(attempts):\n        ancilla = prep_resource_state(theta * (2**ctr))\n        if creg[0] == 0:\n            qasm2.cx(ancilla, target)\n            qasm2.measure(target, creg[0])\n            target = ancilla\n    qasm2.x(target)\n</pre> @qasm2.extended def z_phase_gate_loop(target: qasm2.Qubit, theta: float, attempts: int):     \"\"\"     https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337 Fig. 7     \"\"\"     creg = qasm2.creg(1)  # Implicitly initialized to 0, thanks qasm...     for ctr in range(attempts):         ancilla = prep_resource_state(theta * (2**ctr))         if creg[0] == 0:             qasm2.cx(ancilla, target)             qasm2.measure(target, creg[0])             target = ancilla     qasm2.x(target) <p>Before we analyze these circuits, we must declare a main function which takes no inputs, as qasm2 does not support parameterized circuits or subcircuits.</p> In\u00a0[\u00a0]: Copied! <pre>theta = 0.1  # Specify some Z rotation angle. Note that this is being defined\n</pre> theta = 0.1  # Specify some Z rotation angle. Note that this is being defined <p>outside the main function and being used inside the function via closure.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef postselect_main():\n    target = qasm2.qreg(1)\n    z_phase_gate_postselect(target[0], theta)\n\n\n@qasm2.extended\ndef recursion_main():\n    target = qasm2.qreg(1)\n    z_phase_gate_recursive(target[0], theta)\n\n\n@qasm2.extended\ndef loop_main():\n    target = qasm2.qreg(1)\n    z_phase_gate_loop(target[0], theta, 5)\n</pre> @qasm2.extended def postselect_main():     target = qasm2.qreg(1)     z_phase_gate_postselect(target[0], theta)   @qasm2.extended def recursion_main():     target = qasm2.qreg(1)     z_phase_gate_recursive(target[0], theta)   @qasm2.extended def loop_main():     target = qasm2.qreg(1)     z_phase_gate_loop(target[0], theta, 5) <p>Now lets explore running some interpreters on these circuits. We support the quantum emulation backend PyQrack, which simulates quantum circuits using state vectors.</p> In\u00a0[\u00a0]: Copied! <pre>from bloqade.pyqrack import PyQrack  # noqa: E402\n\ndevice = PyQrack()\nqreg = device.run(postselect_main)\nprint(qreg)\n</pre> from bloqade.pyqrack import PyQrack  # noqa: E402  device = PyQrack() qreg = device.run(postselect_main) print(qreg) <p>Now lets generate the QASM2 code for these circuits! This is an example of code generation, where we go from one DSL and translate to another.</p> In\u00a0[\u00a0]: Copied! <pre>from bloqade.qasm2.emit import QASM2  # noqa: E402\nfrom bloqade.qasm2.parse import pprint  # noqa: E402\n\ntarget = QASM2()\nqasm_postselect = target.emit(postselect_main)\nqasm_loop = target.emit(loop_main)\n\ntry:  # The recursion version has no qasm representation.\n    qasm_recursive = target.emit(recursion_main)\nexcept Exception:\n    print(\"Whoops! We cannot emit calls with return value. This is expected.\")\n\nprint(\"\\n\\n--- Postselect ---\")\npprint(qasm_postselect)\nprint(\"\\n\\n--- Loop ---\")\npprint(qasm_loop)\n</pre> from bloqade.qasm2.emit import QASM2  # noqa: E402 from bloqade.qasm2.parse import pprint  # noqa: E402  target = QASM2() qasm_postselect = target.emit(postselect_main) qasm_loop = target.emit(loop_main)  try:  # The recursion version has no qasm representation.     qasm_recursive = target.emit(recursion_main) except Exception:     print(\"Whoops! We cannot emit calls with return value. This is expected.\")  print(\"\\n\\n--- Postselect ---\") pprint(qasm_postselect) print(\"\\n\\n--- Loop ---\") pprint(qasm_loop) <p>We can also get qasm out as a string</p> In\u00a0[\u00a0]: Copied! <pre>payload = target.emit_str(postselect_main)\n</pre> payload = target.emit_str(postselect_main)"},{"location":"digital/examples/repeat_until_success/#repeat-until-success-with-star-gadget","title":"Repeat Until Success with STAR Gadget\u00b6","text":"<p>In this example, we will demonstrate a near-term fault tolerant gadget which is a repeat-until-success protocol to implement a Z phase gate using a resource state (similar to a T state), Pauli gates, and feed-forward measurement.</p> <p>For more information, see https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337, especially Fig. 7.</p>"},{"location":"quick_start/analog/","title":"Index","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/analog/#quick-start","title":"Quick Start","text":"<p>All the sections below are self-contained, you can click on the links in the Table of Contents to read the relevant parts.</p>"},{"location":"quick_start/analog/#defining-atom-geometry","title":"Defining Atom Geometry","text":"<p>You can import pre-defined geometries based on Bravais lattices from <code>bloqade.analog.atom_arrangement</code>. You may also specify a lattice spacing which dictates the spacing between the atoms as well as the number of atom sites in a certain direction.</p> <pre><code>from bloqade.analog.atom_arrangement import Square, Kagome\n\nsimple_geometry = Square(2, 4, lattice_spacing = 4.0)\nmore_complex_geometry = Kagome(2, 2, lattice_spacing = 2.0)\n</code></pre> <p>You can easily visualize your geometries as well with <code>.show()</code>:</p> <pre><code>more_complex_geometry.show()\n</code></pre> <p>You can also add positions to a pre-defined geometry:</p> <pre><code>from bloqade.analog.atom_arrangement import Square\n\nbase_geometry = Square(2)\ngeometry_with_my_positions = base_geometry.add_position([(10,10), (20,20)])\n</code></pre> <p>As well as apply defects via <code>.apply_defect_density</code>. In the example below we apply a defect with a probability of 0.2:</p> <pre><code>from bloqade.analog.atom_arrangement import Square, Kagome\n\nmore_complex_geometry = Kagome(2, 2, lattice_spacing = 2.0)\ndefective_geometry = more_complex_geometry.apply_defect_density(0.2)\n</code></pre> <p>Or if you want to completely roll out your own atom geometry from scratch just use <code>add_position</code> by itself:</p> <pre><code>from bloqade.analog import start\n\nmy_geometry = start.add_position([(1,2), (3,4), (5,6)])\n</code></pre>"},{"location":"quick_start/analog/#building-waveforms","title":"Building Waveforms","text":"<p>After you've defined a geometry you:</p> <ul> <li>Specify which level coupling to drive: <code>rydberg</code> or <code>hyperfine</code></li> <li>Specify <code>detuning</code>, <code>rabi.amplitude</code> or <code>rabi.phase</code></li> <li>Specify the spatial modulation</li> </ul> <p>Which then leads you to the ability to specify a waveform of interest and begin constructing your pulse sequence. In the example below, we target the ground-Rydberg level coupling to drive with uniform spatial modulation for the Rabi amplitude. Our waveform is a piecewise linear one which ramps from \\(0\\) to \\(5 \\,\\text{rad/us}\\), holds that value for \\(1 \\,\\text{us}\\) and then ramps back down to \\(0 \\,\\text{rad/us}\\).</p> <pre><code>from bloqade.analog import start\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nwaveform_applied = (\n    target_rabi_amplitude\n    .piecewise_linear(durations = [0.06, 1, 0.06], values = [0, 5, 5, 0])\n)\n</code></pre> <p>You aren't restricted to just piecewise linear waveforms however, you can also specify:</p> <ul> <li><code>linear</code> - Define a transition from one value to another over a duration</li> <li><code>constant</code> - Define a fixed value over a duration</li> <li><code>piecewise_constant</code> - Define a step-wise function with specific durations for each step</li> <li><code>poly</code> - Define a polynomial waveform using coefficients over a duration</li> </ul>"},{"location":"quick_start/analog/#arbitrary-functions-as-waveforms","title":"Arbitrary Functions as Waveforms","text":"<p>For more complex waveforms it may provide to be tedious trying to chain together a large number of <code>piecewise_constant</code> or <code>piecewise_linear</code> methods and instead easier to just define the waveform as a function of time.</p> <p>Bloqade lets you easily plug in an arbitrary function with <code>.fn</code>:</p> <pre><code>from bloqade.analog import start\nfrom math import sin\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\n\ndef custom_waveform(t):\n    return 2.0 * sin(t)\n\ncustom_waveform_applied = (\n    target_rabi_amplitude\n    .fn(custom_waveform, duration = 3.0)\n)\n</code></pre> <p>In this form you can immediately emulate it if you'd like but to run this on hardware you need to discretize it. The waveform on hardware has to either be:</p> <ul> <li>Piecewise linear for Rabi amplitude and detuning terms of the Hamiltonian</li> <li>Piecewise constant for the Phase term of the Hamiltonian</li> </ul> <p>Bloqade can automatically perform this conversion with <code>sample()</code>, all you need to do is specify the kind of interpolation and the size of the discretization step in time. Below we set the step duration to be \\(0.05 \\,\\text{us}\\) with <code>\"linear\"</code> interpolation to give us a resulting piecewise linear waveform.</p> <pre><code>custom_discretized_waveform_applied = (\n    target_rabi_amplitude\n    .fn(custom_waveform, duration = 3.0)\n    .sample(0.05, \"linear\")\n)\n</code></pre> <p>Note</p> <p>Programs that have custom functions as waveforms are not fully serializable. This means that when you are saving and reloading results, the original embedded program will be missing that custom waveform. You will still be able to analyze the saved results!</p>"},{"location":"quick_start/analog/#slicing-and-recording-waveforms","title":"Slicing and Recording Waveforms","text":"<p>When you conduct parameter sweeps with your program, you may want to sweep over your program across  time. This will require \"slicing\" your waveforms, where you define the waveform of interest and then, using a variable with <code>.slice</code>, indicate the times at which the waveform duration should be cut short.</p> <p>In the example below we define a simple piecewise linear waveform but slice it starting from a time duration of \\(0 \\,\\text{us}\\) to values between \\(1\\) to \\(2 \\,\\text{us}\\).</p> <pre><code>from bloqade.analog import start\nimport numpy as np\n\nsliced_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.5, 2.5, 0.5], values=[0, 3.0, 3.0, 0]\n    ).slice(start=0, stop=\"run_time\")\n)\n\nrun_times = np.linspace(1.0, 2.0, 10)\nvars_assigned_program = sliced_program.batch_assign(run_time=run_times)\n</code></pre> <p>This program will run fine in emulation but due to hardware constraints certain waveforms (such as those targeting the Rabi Amplitude), the waveform needs to start and end at \\(0 \\,\\text{rad}/\\text{us}\\). Thus, there needs to be a way to slice our waveform but also add an end component to that waveform. <code>.record</code> in Bloqade lets you literally \"record\" the value at the end of a <code>.slice</code> and then use it to construct further parts of the waveform.</p> <p>In the program below the waveform is still sliced but with the help of <code>.record</code> a linear segment that pulls the waveform down to \\(0.0 \\,\\text{rad}/\\text{us}\\) from whatever its current value at the slice is in \\(0.7 \\,\\text{us}\\) is added.</p> <pre><code>from bloqade.analog import start\nimport numpy as np\n\nsliced_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.5, 2.5, 0.5], values=[0, 3.0, 3.0, 0]\n    ).slice(start=0, stop=\"run_time\")\n    .record(\"waveform_value\")\n    .linear(\"rabi_value\", 0.0, 0.7)\n)\n\nrun_times = np.linspace(1.0, 2.0, 10)\nvars_assigned_program = sliced_program.batch_assign(run_time=run_times)\n</code></pre>"},{"location":"quick_start/analog/#waveforms-with-no-geometry","title":"Waveforms with No Geometry","text":"<p>If you have multiple atom geometries you'd like to apply a pulse sequence to or you simply don't want to worry about what atom geometry to start with, you can just build straight off of <code>start</code>:</p> <pre><code>from bloqade.analog import start\n\npulse_sequence = (\n    start\n    .rydberg.rabi.amplitude.uniform\n    .constant(value=1.0, duration=1.0)\n    .parse_sequence()\n)\n</code></pre> <p>You can visualize your sequence as well with <code>.show()</code>:</p> <pre><code>pulse_sequence.show()\n</code></pre> <p></p> <p>And when you're content with it you just <code>.apply()</code> it on the geometries of your choice:</p> <pre><code>from bloqade.analog.atom_arrangement import Honeycomb, Kagome\n\ngeometry_1 = Honeycomb(2, lattice_spacing = 6.0)\ngeometry_2 = Kagome(2, lattice_spacing = 6.0)\n\nprogram_1  = geometry_1.apply(pulse_sequence)\nprogram_2  = geometry_2.apply(pulse_sequence)\n</code></pre>"},{"location":"quick_start/analog/#emulation","title":"Emulation","text":"<p>When you've completed the definition of your program you can use Bloqade's own emulator to get results. The emulation performs the time evolution of the analog Rydberg Hamiltonian. Here we say we want to the program to be run and measurements obtained 1000 times.</p> <pre><code>results = your_program.bloqade.python().run(1000)\n</code></pre> <p>Note</p> <p>If your atoms are particularly close together or the ODE solver gives you the following message:</p> <pre><code>RuntimeError: DOP853/DOPRI5: Problem is probably stiff (interrupted).\n</code></pre> <p>In which case you will need to specify the <code>interaction_picture=True</code> argument:</p> <pre><code>results = your_program.bloqade.python().run(1000, interaction_picture=True)\n</code></pre>"},{"location":"quick_start/analog/#submitting-to-hardware","title":"Submitting to Hardware","text":"<p>To submit your program to hardware ensure you have your AWS Braket credentials loaded. You will need to use the AWS CLI to do this.</p> <p>Then it's just a matter of selecting the Aquila on Braket backend. Before going any further Bloqade provides two options for running your program on actual hardware:</p> <ul> <li>Using <code>.run</code> is blocking, meaning you will not be able to execute anything else while Bloqade waits for results</li> <li>Using <code>.run_async</code> lets you submit to hardware and continue any further execution, while also letting you query the status of your program in the queue.</li> </ul> <p>In the example below we use <code>.run_async</code> to specify the program should be run and measurements obtained 1000 times.</p> <pre><code>async_results = your_program.braket.aquila().run_async(1000)\n</code></pre> <p>We can see the status of our program via:</p> <p><pre><code>async_results.fetch()\n</code></pre> Which gives us the Task ID, a unique identifier for the task as well as the status of the task. In the example below the task is <code>Enqueued</code> meaning it has been successfully created and is awaiting execution on the cloud. When the task is actually running on hardware, the status will change to <code>Running</code>. <pre><code>                                             task ID    status  shots\n0  arn:aws:braket:us-east-1:XXXXXXXXXXXX:quantum-...  Enqueued    100\n</code></pre></p>"},{"location":"quick_start/analog/#analyzing-results","title":"Analyzing Results","text":"<p>When you've retrieved your results from either emulation or hardware you can generate a <code>.report()</code>:</p> <pre><code>report = results.report()\n</code></pre> <p>For the examples below we analyze the results of a two atom program.</p> <p>The report contains useful information such as:</p> <ul> <li> <p>The raw bitstrings measured per each execution of the program <pre><code>report.bitstrings()\n</code></pre> <pre><code>[array([[1, 1],\n        [1, 1],\n        [1, 1],\n        ...,\n        [1, 1],\n        [1, 1],\n        [1, 0]], dtype=int8)]\n</code></pre></p> </li> <li> <p>The number of times each unique bitstring occurred: <pre><code>report.counts()\n</code></pre> <pre><code>[OrderedDict([('11', 892), ('10', 59), ('01', 49)])]\n</code></pre></p> </li> <li> <p>The Rydberg Density for each atom <pre><code>report.rydberg_densities()\n</code></pre> <pre><code>                 0      1\ntask_number\n0            0.053  0.054\n</code></pre></p> </li> </ul> <p>And can also provide useful visual information such as the state of your atoms and the bitstring distribution via:</p> <pre><code>report.show()\n</code></pre> <p></p>"},{"location":"quick_start/analog/#parameter-sweeps","title":"Parameter Sweeps","text":"<p>You can easily do parameter sweeps in emulation and on Aquila with variables. Bloqade automatically detects strings in your program as variables that you can later assign singular or multiple values to.</p> <p>In the example below, we define a program with a singular variable that controls the amplitude of the waveform.</p> <pre><code>from bloqade.analog import start\n\nrabi_oscillations_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.06, 3, 0.06],\n        values=[0, \"rabi_amplitude\", \"rabi_amplitude\", 0]\n    )\n)\n</code></pre> <p>We can assign a single fixed value to the variable:</p> <pre><code>single_value_assignment = rabi_oscillations_program.assign(rabi_amplitude=3.5)\n</code></pre> <p>Or, to perform a sweep, we use <code>.batch_assign</code>:</p> <pre><code>import numpy as np\nrabi_amplitudes = np.linspace(1.0, 2.0, 20)\n\nmultiple_value_assignment = rabi_oscillations_program.batch_assign(rabi_amplitude=rabi_amplitudes)\n</code></pre> <p>This will actually create multiple versions of the program internally, with each program assigned a fixed value from the sweep. Bloqade will automatically handle the compilation of results from these multiple programs in order, meaning there is no major departure from what you saw in analyzing the results of your program.</p> <p>You can also delay assignment of a value to a variable by first declaring it in <code>.args()</code> and then passing a value when you call <code>run</code>:</p> <pre><code>delayed_assignment_program = rabi_oscillations_program.args([\"rabi_amplitude\"])\nresults = delayed_assignment_program.bloqade.python().run(100, args=(1.0,))\n</code></pre> <p>You can alternatively treat the program as a callable after using <code>.args()</code> (note the inverted order of arguments in the call!):</p> <pre><code>delayed_assignment_program = rabi_oscillations_program.args([\"rabi_amplitude\"])\ncallable_program = delayed_assignment_program.bloqade.python()\nresults = callable_program(1.0, shots=100)\n</code></pre> <p>Variables aren't just restricted to having values assigned to them, you can also symbolically manipulate them!</p>"},{"location":"quick_start/analog/#symbolic-parameters","title":"Symbolic Parameters","text":"<p>Variables in Bloqade can also be symbolically manipulated, giving you even more flexibility when you construct your program.</p> <p>In the example below, we externally declare a variable <code>my_var</code> that then has some arithmetic done on it to allow it to have a different value in a later part of the program:</p> <pre><code>from bloqade.analog import start, var\n\nmy_var = var(\"my_variable\")\nwaveform_durations = [0.6, 1.0, 0.6]\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_waveform = (\n    target_rabi_amplitude\n    .piecewise_linear(durations=waveform_durations,\n                      values=[0.0, my_var, my_var, 0.0])\n)\ntarget_detuning = rabi_waveform.detuning.uniform\ndetuning_waveform = (\n    target_detuning\n    .piecewise_linear(durations=waveform_durations,\n                      values=[my_var-1.0, my_var*0.5, my_var/2, my_var+1.0 ])\n)\n</code></pre> <p>You still perform variable assignment just like you normally would:</p> <pre><code>program = detuning_waveform.assign(my_variable=1.0)\n</code></pre> <p>You can also use Python's built-in <code>sum</code> if you want the sum of multiple variables as a value in your program. This is quite useful when it comes to needing to indicate a full duration for a waveform that doesn't need to be split up:</p> <p><pre><code>from bloqade.analog import start, var\n\nvariable_durations = var([\"a\", \"b\", \"c\"])\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_waveform = (\n    target_rabi_amplitude\n    .piecewise_linear(durations=variable_durations,\n                      values=[0.0, 1.5, 1.5, 0.0])\n)\ntarget_detuning = rabi_waveform.detuning.uniform\ndetuning_waveform = (\n    target_detuning\n    .constant(duration=sum(variable_durations),\n              value=16.2)\n)\n</code></pre> We later assign values and Bloqade will automatically handle the summation:</p> <pre><code>program = detuning_waveform.assign(a=0.5, b=1.2, c=0.5)\n</code></pre>"},{"location":"quick_start/analog/#saving-and-loading-results","title":"Saving and Loading Results","text":"<p>You can save your results in JSON format using Bloqade's <code>save</code> function:</p> <pre><code>from bloqade.analog import start, save\n\nyour_program = ...\nemulation_results = your_program.bloqade.python().run(100)\nhardware_results = your_program.braket.aquila.run_async(100)\n\nsave(emulation_results, \"emulation_results.json\")\nsave(hardware_results, \"hardware_results.json\")\n</code></pre> <p>And later reload them into Python using the <code>load</code> function:</p> <pre><code>from bloqade.analog import load\nemulation_results = load(\"emulation_results.json\")\nhardware_results = load(\"hardware_results.json\")\n</code></pre>"},{"location":"quick_start/circuits/","title":"Digital Quantum Computing with circuits","text":"<p>This section provides the quick start guide for developing quantum programs represented by circuits using Bloqade. Circuits are a general-purpose and powerful way of representing arbitrary computations. For a few examples please refer to our examples.</p>"},{"location":"quick_start/circuits/#open-quantum-assembly-language-qasm2-and-beyond","title":"Open Quantum Assembly Language (QASM2) and beyond","text":"<p>We have chosen to closely mirror the semantics of the Open Quantum Assembly Language (QASM2) in bloqade.circuits. The QASM2 dialect is a simple quantum assembly language that allows you to write quantum circuits in a human-readable format. However, one should note that QASM2 is a very restricted language and does not support all the features of a high-level language.</p> <p>For example, there is a separation of gate routines declared with <code>gate</code> and main program written as a sequence of gate applications. While the gate routine is similar to a function in many ways, it does not support high-level features such as recursion (due to lack of <code>if</code> statement support inside) or control flows.</p> <p>Indeed, bloqade.circuits is designed with the notion of kernels in mind by decorating functions with a <code>@qasm2.extended</code> decorator. The python code is interpreted and parsed by the Kirin compiler toolchain and lowered to an abstract representation of the program. These kernels can include classical computation and the usual programming structures-- if/else, for and while loops, function inputs, and the like, as one is used to in Python.</p> <p>Additionally, the QASM2 representations of bloqade.circuits have been extended to include a key advantage of reconfigurable neutral atom hardware: parallelism. For example, one can represent a CZ gate applied to many qubit pairs at once as</p> <p><pre><code>@qasm2.extended\ndef parallel_cz(controls:ilist[qasm2.Qubit],targets:ilist[qasm2.Qubit]):\n    for ctr in range(len(controls)):\n        qasm2.cz(ctrl=controls[0],qarg=controls[1])\n</code></pre> or equivalently use a SIMD (single instruction multiple data)-like instruction to explicitly flag the parallelism <pre><code>@qasm2.extended\ndef simd_cz(controls:ilist[qasm2.Qubit],targets:ilist[qasm2.Qubit]):\n    qasm2.parallel.cz(ctrls=controls,qargs=targets)\n</code></pre> Both will ultimately emit the exact same QASM code, but the latter snippet represents the kind of parallelism that can be leveraged by reconfigurable neutral atom hardware to more efficiently execute a program.</p> <p>While in our initial release we support QASM2 as the first eDSL, we plan to use it as a compilation target instead of a programming language for long-term development. We are working on a more expressive language that will be more suitable for quantum programming in the error-corrected era.</p>"},{"location":"quick_start/circuits/#quick-example","title":"Quick Example","text":"<p>You can program kernels and quantum programs using the <code>qasm2.extended</code> decorator, such as the following Quantum Fourier Transform (QFT) circuit:</p> <pre><code>import math\nfrom bloqade import qasm2\n\n@qasm2.extended\ndef qft(qreg: qasm2.QReg, n: int):\n    if n == 0:\n        return qreg\n\n    qasm2.h(qreg[0])\n    for i in range(1, n):\n        qasm2.cu1(qreg[i], qreg[0], 2 * math.pi / 2**i)\n    qft(qreg, n - 1)\n    return qreg\n</code></pre> <p>While the syntax is similar to Python, the <code>qasm2.extended</code> decorator actually compiles the <code>qft</code> function into lower-level intermediate representation (IR) code that can be later interpreted, analyzed, or executed on quantum hardware. Observe that this function cannot immediately compile down to QASM as it takes parametrized inputs, and is called recursively.</p> <p>You can inspect the initial IR code by calling the pretty printer:</p> <pre><code>qft.print()\n</code></pre> <p></p> <p>And emit QASM2 code</p> <pre><code>from bloqade.qasm2.emit import QASM2 # the QASM2 target\nfrom bloqade.qasm2.parse import pprint # the QASM2 pretty printer\n\ntarget = QASM2()\nast = target.emit(main)\npprint(ast)\n</code></pre> <p></p>"},{"location":"quick_start/circuits/#understanding-the-compilation-process","title":"Understanding the compilation process","text":"<p>The compilation process is divided into several stages:</p> <ol> <li>Lowering: the decorator <code>qasm2.extended</code> takes the Python Abstract Syntax Tree (AST) and lowers it into Kirin IR in the Static Single Assignment (SSA) form.</li> <li>Interpretation: when invoking the PyQrack backend, the IR code is interpreted via Kirin's IR interpreter (missing link) with the PyQrack runtime backend.</li> <li>Target code generation: when emitting QASM2 code:</li> <li>The IR code gets aggressively inlined and all constant expressions are evaluated.</li> <li>All loops and control flow are unrolled.</li> <li>All compatible Python expressions (e.g <code>sin</code>, arithmetics) are translated into QASM2 expression.</li> <li>The QASM2 code is emitted as QASM2 AST for pretty printing.</li> </ol>"},{"location":"quick_start/circuits/#progressive-compilation","title":"Progressive compilation","text":"<p>As well as writing circuit executions, you can also progressively transform and compile that circuit. For example, you may want to lower arbitrary single qubit unitaries into hardware-specific unitaries, as is done in this example. For more details on the kinds of circuit-level compiler passes and how to write your own, see here</p>"},{"location":"quick_start/circuits/#dialect-groups","title":"Dialect groups","text":"<p>Bloqade provides a set of dialects (missing link) for QASM2 and our custom extensions to model parallel gates in neutral atom architectures. The basic QASM2 functionality can be enabled via</p> <pre><code>pip install bloqade[qasm2]\n</code></pre>"},{"location":"quick_start/circuits/#extended-qasm","title":"Extended QASM","text":"<p>The decorator <code>qasm2.extended</code> is a group of smaller dialects:</p> <pre><code>extended = structural_no_opt.union(\n     [\n         inline,\n         uop,\n         glob,\n         noise,\n         parallel,\n         core,\n     ]\n )\n</code></pre> <p>where <code>structural_no_opt</code> is the base dialect group that provides the basic control flow, common Python expressions (but not all), then:</p> <ul> <li><code>core</code> provides the core QASM2 operations such as register allocation, measurement and reset.</li> <li><code>uop</code> provides the unary operations, such as standard Pauli gates, rotation gates, etc.</li> </ul> <p>The following dialects are specific to neutral atom quantum computing as an extension:</p> <ul> <li><code>glob</code> provides the global gates (Rydberg specific)</li> <li><code>noise</code> provides the noise channels</li> <li><code>parallel</code> provides the parallel gate support (Rydberg specific).</li> <li><code>inline</code> dialect provides the inline QASM string</li> </ul>"},{"location":"quick_start/circuits/#strict-qasm2-mode","title":"Strict QASM2 mode","text":"<p>While the <code>qasm2.extended</code> decorator provides a lot of high-level features as an extension of QASM2, you may want to program in strict QASM2 mode for compatibility reasons. You can do this by using the <code>qasm2.main</code> and <code>qasm2.gate</code> decorators:</p> <pre><code>@qasm2.main\ndef main():\n    qasm2.h(0)\n    qasm2.cx(0, 1)\n    qasm2.measure(0)\n    qasm2.measure(1)\n    return qasm2.qreg(2)\n</code></pre> <p>which corresponding to the following QASM2 code:</p> <pre><code>OPENQASM 2.0;\ninclude \"qelib1.inc\";\n\nqreg q[2];\ncreg c[2];\n\nh q[0];\ncx q[0], q[1];\nmeasure q[0] -&gt; c[0];\nmeasure q[1] -&gt; c[1];\n</code></pre> <p>Note that the <code>return</code> values are all ignored due to lack of equivalent in QASM2.</p>"},{"location":"quick_start/circuits/API/qasm2_core/","title":"QASM2 Core","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/API/qasm2_inline_defunct/","title":"Qasm2 inline defunct","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p> <p>?? Merge with qasm2 core API to cut down on pages?</p>"},{"location":"quick_start/circuits/API/qasm2_noise/","title":"QASM2 Noise","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/API/qasm2_parallel/","title":"QASM2 Parallel","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/API/qasm2_uop/","title":"QASM2 Uop","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p> <p>?? Merge with qasm2 core API to cut down on pages?</p>"},{"location":"quick_start/circuits/compiler_passes/","title":"Index","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/compiler_passes/asap_parallelism/","title":"ASAP Parallelism","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/compiler_passes/circuit_simplification/","title":"Circuit simplification","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/compiler_passes/native_gate_rewrite/","title":"Native gate rewrite","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/interpreters_and_analysis/","title":"Index","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/interpreters_and_analysis/pyqrack_emulator/","title":"PyQrack emulator","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/interpreters_and_analysis/pyqrack_emulator/#running-simulations","title":"Running simulations","text":"<p>The program can be executed via a simulator backend, e.g. PyQrack, you can install it via</p> <pre><code>pip install bloqade-pyqrack[backend]\n</code></pre> <p>with the <code>backend</code> being one of <code>pyqrack</code>, <code>pyqrack-cpu</code>, <code>pyqrack-cuda</code> depending on the hardware and OS you have. See README for mote details.</p> <pre><code>@qasm2.extended\ndef main():\n    return qft(qasm2.qreg(3), 3)\n\ndevice = PyQrack()\nqreg = device.run(main)\nprint(qreg)\n</code></pre>"},{"location":"quick_start/circuits/interpreters_and_analysis/qasm2_codegen/","title":"QASM2 Codegen","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/interpreters_and_analysis/qasm2_codegen/#emitting-qasm2-code","title":"Emitting QASM2 code","text":"<p>You can also emit QASM2 code from the IR code:</p> <pre><code>from bloqade.qasm2.emit import QASM2 # the QASM2 target\nfrom bloqade.qasm2.parse import pprint # the QASM2 pretty printer\n\ntarget = QASM2()\nast = target.emit(main)\npprint(ast)\n</code></pre> <p></p>"},{"location":"reference/bloqade/test_utils/","title":"Test utils","text":""},{"location":"reference/bloqade/types/","title":"Types","text":"<p>Bloqade types.</p> <p>This module defines the basic types used in Bloqade eDSLs.</p>"},{"location":"reference/bloqade/types/#bloqade.types.QubitType","title":"QubitType  <code>module-attribute</code>","text":"<pre><code>QubitType = PyClass(Qubit)\n</code></pre> <p>Kirin type for a qubit.</p>"},{"location":"reference/bloqade/types/#bloqade.types.Qubit","title":"Qubit","text":"<p>               Bases: <code>ABC</code></p> <p>Runtime representation of a qubit.</p> Note <p>This is the base class of more specific qubit types, such as a reference to a piece of quantum register in some quantum register dialects.</p>"},{"location":"reference/bloqade/analysis/","title":"Index","text":""},{"location":"reference/bloqade/analysis/address/","title":"Index","text":""},{"location":"reference/bloqade/analysis/address/analysis/","title":"Analysis","text":""},{"location":"reference/bloqade/analysis/address/analysis/#bloqade.analysis.address.analysis.AddressAnalysis","title":"AddressAnalysis","text":"<p>               Bases: <code>Forward[Address]</code></p> <p>This analysis pass can be used to track the global addresses of qubits and wires.</p>"},{"location":"reference/bloqade/analysis/address/analysis/#bloqade.analysis.address.analysis.AddressAnalysis.qubit_count","title":"qubit_count  <code>property</code>","text":"<pre><code>qubit_count: int\n</code></pre> <p>Total number of qubits found by the analysis.</p>"},{"location":"reference/bloqade/analysis/address/impls/","title":"Impls","text":"<p>qubit.address method table for a few builtin dialects.</p>"},{"location":"reference/bloqade/analysis/address/lattice/","title":"Lattice","text":""},{"location":"reference/bloqade/noise/","title":"Index","text":""},{"location":"reference/bloqade/noise/native/","title":"Index","text":"<p>NOTE: This module is not guaranteed to be supported long-term in bloqade. We will be moving towards a more general approach to noise modeling in the future.</p>"},{"location":"reference/bloqade/noise/native/model/","title":"Model","text":""},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.GateNoiseParams","title":"GateNoiseParams  <code>dataclass</code>","text":"<pre><code>GateNoiseParams(\n    *,\n    local_px: float = 0.001,\n    local_py: float = 0.001,\n    local_pz: float = 0.001,\n    local_loss_prob: float = 0.0001,\n    global_px: float = 0.001,\n    global_py: float = 0.001,\n    global_pz: float = 0.001,\n    global_loss_prob: float = 0.001,\n    cz_paired_gate_px: float = 0.001,\n    cz_paired_gate_py: float = 0.001,\n    cz_paired_gate_pz: float = 0.001,\n    cz_gate_loss_prob: float = 0.001,\n    cz_unpaired_gate_px: float = 0.001,\n    cz_unpaired_gate_py: float = 0.001,\n    cz_unpaired_gate_pz: float = 0.001,\n    cz_unpaired_loss_prob: float = 0.001\n)\n</code></pre> <p>Parameters for gate noise.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.GateNoiseParams.cz_gate_loss_prob","title":"cz_gate_loss_prob  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_gate_loss_prob: float = field(\n    default=0.001, kw_only=True\n)\n</code></pre> <p>The error probability for a loss during CZ gate operation when two qubits are within blockade radius.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.GateNoiseParams.cz_paired_gate_px","title":"cz_paired_gate_px  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_paired_gate_px: float = field(\n    default=0.001, kw_only=True\n)\n</code></pre> <p>The error probability for a Pauli-X error during CZ gate operation when two qubits are within blockade radius.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.GateNoiseParams.cz_paired_gate_py","title":"cz_paired_gate_py  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_paired_gate_py: float = field(\n    default=0.001, kw_only=True\n)\n</code></pre> <p>The error probability for a Pauli-Y error during CZ gate operation when two qubits are within blockade radius.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.GateNoiseParams.cz_paired_gate_pz","title":"cz_paired_gate_pz  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_paired_gate_pz: float = field(\n    default=0.001, kw_only=True\n)\n</code></pre> <p>The error probability for a Pauli-Z error during CZ gate operation when two qubits are within blockade radius.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.GateNoiseParams.cz_unpaired_gate_px","title":"cz_unpaired_gate_px  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_unpaired_gate_px: float = field(\n    default=0.001, kw_only=True\n)\n</code></pre> <p>The error probability for Pauli-X error during CZ gate operation when another qubit is not within blockade radius.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.GateNoiseParams.cz_unpaired_gate_py","title":"cz_unpaired_gate_py  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_unpaired_gate_py: float = field(\n    default=0.001, kw_only=True\n)\n</code></pre> <p>The error probability for Pauli-Y error during CZ gate operation when another qubit is not within blockade radius.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.GateNoiseParams.cz_unpaired_gate_pz","title":"cz_unpaired_gate_pz  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_unpaired_gate_pz: float = field(\n    default=0.001, kw_only=True\n)\n</code></pre> <p>The error probability for Pauli-Z error during CZ gate operation when another qubit is not within blockade radius.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.GateNoiseParams.cz_unpaired_loss_prob","title":"cz_unpaired_loss_prob  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_unpaired_loss_prob: float = field(\n    default=0.001, kw_only=True\n)\n</code></pre> <p>The error probability for a loss during CZ gate operation when another qubit is not within blockade radius.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.GateNoiseParams.global_loss_prob","title":"global_loss_prob  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>global_loss_prob: float = field(default=0.001, kw_only=True)\n</code></pre> <p>The error probability for a loss during a global single qubit gate operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.GateNoiseParams.global_px","title":"global_px  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>global_px: float = field(default=0.001, kw_only=True)\n</code></pre> <p>The error probability for a Pauli-X error during a global single qubit gate operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.GateNoiseParams.global_py","title":"global_py  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>global_py: float = field(default=0.001, kw_only=True)\n</code></pre> <p>The error probability for a Pauli-Y error during a global single qubit gate operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.GateNoiseParams.global_pz","title":"global_pz  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>global_pz: float = field(default=0.001, kw_only=True)\n</code></pre> <p>The error probability for a Pauli-Z error during a global single qubit gate operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.GateNoiseParams.local_loss_prob","title":"local_loss_prob  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>local_loss_prob: float = field(default=0.0001, kw_only=True)\n</code></pre> <p>The error probability for a loss during a local single qubit gate operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.GateNoiseParams.local_px","title":"local_px  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>local_px: float = field(default=0.001, kw_only=True)\n</code></pre> <p>The error probability for a Pauli-X error during a local single qubit gate operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.GateNoiseParams.local_py","title":"local_py  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>local_py: float = field(default=0.001, kw_only=True)\n</code></pre> <p>The error probability for a Pauli-Y error during a local single qubit gate operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.GateNoiseParams.local_pz","title":"local_pz  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>local_pz: float = field(default=0.001, kw_only=True)\n</code></pre> <p>The error probability for a Pauli-Z error during a local single qubit gate operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseModelABC","title":"MoveNoiseModelABC  <code>dataclass</code>","text":"<pre><code>MoveNoiseModelABC(\n    params: MoveNoiseParams = MoveNoiseParams(),\n)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Abstract base class for noise based on atom movement.</p> <p>This class defines the interface for a noise model. The gate noise is calculated form the parameters provided in this dataclass which can be updated when inheriting from this class. The move error is calculated by implementing the parallel_cz_errors method which takes a set of ctrl and qarg qubits and returns a noise model for all the qubits. The noise model is a dictionary with the keys being the error rates for the qubits and the values being the list of qubits that the error rate applies to.</p> <p>Once implemented the class can be used with the NoisePass to analyze a circuit and apply the noise model to the circuit.</p> <p>NOTE: This model is not guaranteed to be supported long-term in bloqade. We will be moving towards a more general approach to noise modeling in the future.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseModelABC.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params: MoveNoiseParams = field(\n    default_factory=MoveNoiseParams\n)\n</code></pre> <p>Parameters for calculating move noise.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseModelABC.join_binary_probs","title":"join_binary_probs  <code>classmethod</code>","text":"<pre><code>join_binary_probs(p1: float, *args: float) -&gt; float\n</code></pre> <p>Merge the probabilities of an event happening if the event can only happen once.</p> <p>For example, finding the effective probability of losing an atom from multiple sources, since a qubit can only happen once. This is done by using the formula:</p> <p>p = p1 * (1 - p2) + p2 * (1 - p1)</p> <p>applied recursively to all the probabilities in the list.</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>float</code> <p>The probability of the event happening.</p> required <code>arg</code> <code>float</code> <p>The probabilities of the event happening from other sources.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The effective probability of the event happening.</p> Source code in <code>src/bloqade/noise/native/model.py</code> <pre><code>@classmethod\ndef join_binary_probs(cls, p1: float, *args: float) -&gt; float:\n    \"\"\"Merge the probabilities of an event happening if the event can only happen once.\n\n    For example, finding the effective probability of losing an atom from multiple sources, since\n    a qubit can only happen once. This is done by using the formula:\n\n    p = p1 * (1 - p2) + p2 * (1 - p1)\n\n    applied recursively to all the probabilities in the list.\n\n    Args:\n        p1 (float): The probability of the event happening.\n        arg (float): The probabilities of the event happening from other sources.\n\n    Returns:\n        float: The effective probability of the event happening.\n\n    \"\"\"\n    if len(args) == 0:\n        return p1\n    else:\n        p2 = cls.join_binary_probs(*args)\n        return p1 * (1 - p2) + p2 * (1 - p1)\n</code></pre>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseModelABC.parallel_cz_errors","title":"parallel_cz_errors  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>parallel_cz_errors(\n    ctrls: List[int], qargs: List[int], rest: List[int]\n) -&gt; Dict[Tuple[float, float, float, float], List[int]]\n</code></pre> <p>Takes a set of ctrls and qargs and returns a noise model for all qubits.</p> Source code in <code>src/bloqade/noise/native/model.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef parallel_cz_errors(\n    cls, ctrls: List[int], qargs: List[int], rest: List[int]\n) -&gt; Dict[Tuple[float, float, float, float], List[int]]:\n    \"\"\"Takes a set of ctrls and qargs and returns a noise model for all qubits.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseModelABC.poisson_pauli_prob","title":"poisson_pauli_prob  <code>staticmethod</code>","text":"<pre><code>poisson_pauli_prob(rate: float, duration: float) -&gt; float\n</code></pre> <p>Calculate the number of noise events and their probabilities for a given rate and duration.</p> Source code in <code>src/bloqade/noise/native/model.py</code> <pre><code>@staticmethod\ndef poisson_pauli_prob(rate: float, duration: float) -&gt; float:\n    \"\"\"Calculate the number of noise events and their probabilities for a given rate and duration.\"\"\"\n    assert duration &gt;= 0, \"Duration must be non-negative\"\n    assert rate &gt;= 0, \"Rate must be non-negative\"\n    return 0.5 * (1 - math.exp(-2 * rate * duration))\n</code></pre>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseParams","title":"MoveNoiseParams  <code>dataclass</code>","text":"<pre><code>MoveNoiseParams(\n    *,\n    idle_px_rate: float = 1e-06,\n    idle_py_rate: float = 1e-06,\n    idle_pz_rate: float = 1e-06,\n    idle_loss_rate: float = 1e-06,\n    move_px_rate: float = 1e-06,\n    move_py_rate: float = 1e-06,\n    move_pz_rate: float = 1e-06,\n    move_loss_rate: float = 1e-06,\n    pick_px: float = 0.001,\n    pick_py: float = 0.001,\n    pick_pz: float = 0.001,\n    pick_loss_prob: float = 0.0001,\n    move_speed: float = 0.5,\n    storage_spacing: float = 4.0\n)\n</code></pre>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseParams.idle_loss_rate","title":"idle_loss_rate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idle_loss_rate: float = field(default=1e-06, kw_only=True)\n</code></pre> <p>The error rate (prob/microsecond) for a loss during an idle operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseParams.idle_px_rate","title":"idle_px_rate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idle_px_rate: float = field(default=1e-06, kw_only=True)\n</code></pre> <p>The error rate (prob/microsecond) for a Pauli-X error during an idle operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseParams.idle_py_rate","title":"idle_py_rate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idle_py_rate: float = field(default=1e-06, kw_only=True)\n</code></pre> <p>The error rate (prob/microsecond) for a Pauli-Y error during an idle operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseParams.idle_pz_rate","title":"idle_pz_rate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idle_pz_rate: float = field(default=1e-06, kw_only=True)\n</code></pre> <p>The error rate (prob/microsecond) for a Pauli-Z error during an idle operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseParams.move_loss_rate","title":"move_loss_rate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>move_loss_rate: float = field(default=1e-06, kw_only=True)\n</code></pre> <p>The error rate e (prob/microsecond) for a loss during a move operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseParams.move_px_rate","title":"move_px_rate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>move_px_rate: float = field(default=1e-06, kw_only=True)\n</code></pre> <p>The error rate (prob/microsecond) for a Pauli-X error during a move operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseParams.move_py_rate","title":"move_py_rate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>move_py_rate: float = field(default=1e-06, kw_only=True)\n</code></pre> <p>The error rate e (prob/microsecond) for a Pauli-Y error during a move operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseParams.move_pz_rate","title":"move_pz_rate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>move_pz_rate: float = field(default=1e-06, kw_only=True)\n</code></pre> <p>The error rate e (prob/microsecond) for a Pauli-Z error during a move operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseParams.move_speed","title":"move_speed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>move_speed: float = field(default=0.5, kw_only=True)\n</code></pre> <p>Maximum speed of the qubits during a move operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseParams.pick_loss_prob","title":"pick_loss_prob  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pick_loss_prob: float = field(default=0.0001, kw_only=True)\n</code></pre> <p>The error rate for a loss during a pick operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseParams.pick_px","title":"pick_px  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pick_px: float = field(default=0.001, kw_only=True)\n</code></pre> <p>The error rate (prob per pick operation)  for a Pauli-X error during a pick operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseParams.pick_py","title":"pick_py  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pick_py: float = field(default=0.001, kw_only=True)\n</code></pre> <p>The error rate (prob per pick operation) for a Pauli-Y error during a pick operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseParams.pick_pz","title":"pick_pz  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pick_pz: float = field(default=0.001, kw_only=True)\n</code></pre> <p>The error rate (prob per pick operation) for a Pauli-Z error during a pick operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.MoveNoiseParams.storage_spacing","title":"storage_spacing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>storage_spacing: float = field(default=4.0, kw_only=True)\n</code></pre> <p>Spacing between the qubits in the storage zone.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.SingleZoneLayoutABC","title":"SingleZoneLayoutABC  <code>dataclass</code>","text":"<pre><code>SingleZoneLayoutABC(\n    params: MoveNoiseParams = MoveNoiseParams(),\n    *,\n    gate_noise_params: GateNoiseParams = GateNoiseParams()\n)\n</code></pre> <p>               Bases: <code>MoveNoiseModelABC</code></p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.SingleZoneLayoutABC.calculate_move_duration","title":"calculate_move_duration  <code>abstractmethod</code>","text":"<pre><code>calculate_move_duration(\n    ctrls: List[int], qargs: List[int]\n) -&gt; float\n</code></pre> <p>Calculate the time it takes to reconfigure the atom for executing the CZ gates.</p> Source code in <code>src/bloqade/noise/native/model.py</code> <pre><code>@abc.abstractmethod\ndef calculate_move_duration(self, ctrls: List[int], qargs: List[int]) -&gt; float:\n    \"\"\"Calculate the time it takes to reconfigure the atom for executing the CZ gates.\"\"\"\n</code></pre>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.SingleZoneLayoutABC.parallel_cz_errors","title":"parallel_cz_errors","text":"<pre><code>parallel_cz_errors(\n    ctrls: List[int], qargs: List[int], rest: List[int]\n) -&gt; Dict[Tuple[float, float, float, float], List[int]]\n</code></pre> <p>Apply parallel gates by moving ctrl qubits to qarg qubits.</p> Source code in <code>src/bloqade/noise/native/model.py</code> <pre><code>def parallel_cz_errors(\n    self, ctrls: List[int], qargs: List[int], rest: List[int]\n) -&gt; Dict[Tuple[float, float, float, float], List[int]]:\n    \"\"\"Apply parallel gates by moving ctrl qubits to qarg qubits.\"\"\"\n\n    move_duration = self.calculate_move_duration(ctrls, qargs)\n\n    # idle errors during atom moves\n    idle_px_time = self.poisson_pauli_prob(self.params.idle_px_rate, move_duration)\n    idle_py_time = self.poisson_pauli_prob(self.params.idle_py_rate, move_duration)\n    idle_pz_time = self.poisson_pauli_prob(self.params.idle_pz_rate, move_duration)\n    idle_p_loss_time = self.poisson_pauli_prob(\n        self.params.idle_loss_rate, move_duration\n    )\n\n    # even qubits not involved in the gate can still experience unpaired errors\n    idle_px = self.join_binary_probs(\n        self.gate_noise_params.cz_unpaired_gate_px, idle_px_time\n    )\n    idle_py = self.join_binary_probs(\n        self.gate_noise_params.cz_unpaired_gate_py, idle_py_time\n    )\n    idle_pz = self.join_binary_probs(\n        self.gate_noise_params.cz_unpaired_gate_pz, idle_pz_time\n    )\n    idle_p_loss = self.join_binary_probs(\n        self.gate_noise_params.cz_unpaired_loss_prob, idle_p_loss_time\n    )\n\n    errors = {(idle_px, idle_py, idle_pz, idle_p_loss): rest}\n\n    # error during the move\n    move_px_time = self.poisson_pauli_prob(self.params.move_px_rate, move_duration)\n    move_py_time = self.poisson_pauli_prob(self.params.move_py_rate, move_duration)\n    move_pz_time = self.poisson_pauli_prob(self.params.move_pz_rate, move_duration)\n    move_p_loss_time = self.poisson_pauli_prob(\n        self.params.move_loss_rate, move_duration\n    )\n    # error coming from picking up the qubits\n    px_moved = self.join_binary_probs(self.params.pick_px, move_px_time)\n    py_moved = self.join_binary_probs(self.params.pick_py, move_py_time)\n    pz_moved = self.join_binary_probs(self.params.pick_pz, move_pz_time)\n    p_loss_moved = self.join_binary_probs(\n        self.params.pick_loss_prob, move_p_loss_time\n    )\n\n    errors[(px_moved, py_moved, pz_moved, p_loss_moved)] = sorted(ctrls + qargs)\n\n    return errors\n</code></pre>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.TwoRowZoneModel","title":"TwoRowZoneModel  <code>dataclass</code>","text":"<pre><code>TwoRowZoneModel(\n    params: MoveNoiseParams = MoveNoiseParams(),\n    gate_zone_y_offset: float = 20.0,\n    gate_spacing: float = 20.0,\n)\n</code></pre> <p>               Bases: <code>MoveNoiseModelABC</code></p> <p>This model assumes that the qubits are arranged in a single storage row with a row corresponding to a gate zone below it.</p> <p>The CZ gate noise is calculated using the following heuristic: The idle error is calculated by the total duration require to do the move and entable the qubits. Not every pair can be entangled at the same time, so we first deconflict the qargs assuming by finding subsets in which both the ctrl and the qarg qubits are in ascending order. This breaks the pairs into groups that can be moved and entangled separately. We then take each group and assign each pair to a gate zone slot. The slots are allocated by starting from the middle of the atoms and moving outwards making sure to keep the ctrl qubits in ascending order. The time to move a group is calculated by finding the maximum travel distance of the qarg and ctrl qubits and dviding by the move speed. The total move time is the sum of all the group move times. The error rate for all the qubits is then calculated by using the poisson_pauli_prob function. An additional error for the pick operation is calculated by joining the binary probabilities of the pick operation and the move operation.</p>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.TwoRowZoneModel.assign_gate_slots","title":"assign_gate_slots","text":"<pre><code>assign_gate_slots(\n    ctrls: Sequence[int], qargs: Sequence[int]\n) -&gt; Dict[int, Tuple[int, int]]\n</code></pre> <p>Allocate slots for the qubits to move to. start from middle of atoms and move outwards making sure to keep the ctrl qubits in ascending order.</p> <p>Note that we can do this because the move strategy is to move the ctrl qubits separately from the qarg qubits, thus we don't have to worry about qarg qubits crossing the ctrl qubits and vice versa. We pick the median of all the atoms because it distributes the qubits as evenly as possible over the gate zone.</p> Source code in <code>src/bloqade/noise/native/model.py</code> <pre><code>def assign_gate_slots(\n    self, ctrls: Sequence[int], qargs: Sequence[int]\n) -&gt; Dict[int, Tuple[int, int]]:\n    \"\"\"Allocate slots for the qubits to move to. start from middle of atoms and move outwards\n    making sure to keep the ctrl qubits in ascending order.\n\n    Note that we can do this because the move strategy is to move the ctrl qubits separately\n    from the qarg qubits, thus we don't have to worry about qarg qubits crossing the ctrl qubits\n    and vice versa. We pick the median of all the atoms because it distributes the qubits\n    as evenly as possible over the gate zone.\n\n    \"\"\"\n    assert len(ctrls) == len(qargs), \"Number of ctrls and qargs must be equal\"\n    addr_pairs = sorted(zip(ctrls, qargs), key=lambda x: x[0])\n    # sort by the distance between the ctrl and qarg qubits\n\n    ctrls, qargs = list(zip(*addr_pairs))\n\n    n_ctrls = len(ctrls)\n\n    ctrl_median = (\n        ctrls[n_ctrls // 2]\n        if n_ctrls % 2 == 1\n        else (ctrls[n_ctrls // 2 - 1] + ctrls[n_ctrls // 2]) / 2\n    )\n\n    all_addr = sorted(ctrls + qargs)\n    spatial_median = self.params.storage_spacing * (all_addr[0] + all_addr[-1]) / 2\n\n    addr_pairs.sort(key=lambda x: abs(x[0] - ctrl_median))\n\n    slots = {}\n    med_slot = round(spatial_median / self.gate_spacing)\n\n    left_slot = med_slot\n    right_slot = med_slot\n    slots[med_slot] = addr_pairs.pop(0)\n    while addr_pairs:\n        ctrl, qarg = addr_pairs.pop(0)\n\n        if ctrl &lt; ctrl_median:\n            slots[left_slot := left_slot - 1] = (ctrl, qarg)\n        else:\n            slots[right_slot := right_slot + 1] = (ctrl, qarg)\n\n    return slots\n</code></pre>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.TwoRowZoneModel.calculate_move_duration","title":"calculate_move_duration","text":"<pre><code>calculate_move_duration(\n    slots: Dict[int, Tuple[int, int]],\n) -&gt; float\n</code></pre> <p>Calculate the time it takes to move the qubits from the ctrl to the qarg qubits.</p> Source code in <code>src/bloqade/noise/native/model.py</code> <pre><code>def calculate_move_duration(self, slots: Dict[int, Tuple[int, int]]) -&gt; float:\n    \"\"\"Calculate the time it takes to move the qubits from the ctrl to the qarg qubits.\"\"\"\n\n    qarg_x_distance = float(\"-inf\")\n    ctrl_x_distance = float(\"-inf\")\n\n    for slot, (ctrl, qarg) in slots.items():\n        qarg_x_distance = max(\n            qarg_x_distance,\n            abs(qarg * self.params.storage_spacing - slot * self.gate_spacing),\n        )\n        ctrl_x_distance = max(\n            ctrl_x_distance,\n            abs(ctrl * self.params.storage_spacing - slot * self.gate_spacing),\n        )\n\n    qarg_max_distance = math.sqrt(qarg_x_distance**2 + self.gate_zone_y_offset**2)\n    ctrl_max_distance = math.sqrt(\n        ctrl_x_distance**2 + (self.gate_zone_y_offset - 3) ** 2\n    )\n\n    return (qarg_max_distance + ctrl_max_distance) / self.params.move_speed\n</code></pre>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.TwoRowZoneModel.deconflict","title":"deconflict","text":"<pre><code>deconflict(\n    ctrls: List[int], qargs: List[int]\n) -&gt; List[Tuple[Tuple[int, ...], Tuple[int, ...]]]\n</code></pre> <p>Return a list of groups of ctrl and qarg qubits that can be moved and entangled separately.</p> Source code in <code>src/bloqade/noise/native/model.py</code> <pre><code>def deconflict(\n    self, ctrls: List[int], qargs: List[int]\n) -&gt; List[Tuple[Tuple[int, ...], Tuple[int, ...]]]:\n    \"\"\"Return a list of groups of ctrl and qarg qubits that can be moved and entangled separately.\"\"\"\n    # sort by ctrl qubit first to guarantee that they will be in ascending order\n    sorted_pairs = sorted(zip(ctrls, qargs))\n\n    groups = []\n    # group by qarg only putting it in a group if the qarg is greater than the last qarg in the group\n    # thus ensuring that the qargs are in ascending order\n    while len(sorted_pairs) &gt; 0:\n        ctrl, qarg = sorted_pairs.pop(0)\n\n        found = False\n        for group in groups:\n            if group[-1][1] &lt; qarg:\n                group.append((ctrl, qarg))\n                found = True\n                break\n        if not found:\n            groups.append([(ctrl, qarg)])\n\n    return [tuple(zip(*group)) for group in groups]\n</code></pre>"},{"location":"reference/bloqade/noise/native/model/#bloqade.noise.native.model.TwoRowZoneModel.parallel_cz_errors","title":"parallel_cz_errors","text":"<pre><code>parallel_cz_errors(\n    ctrls: List[int], qargs: List[int], rest: List[int]\n) -&gt; Dict[Tuple[float, float, float, float], List[int]]\n</code></pre> <p>Apply parallel gates by moving ctrl qubits to qarg qubits.</p> Source code in <code>src/bloqade/noise/native/model.py</code> <pre><code>def parallel_cz_errors(\n    self, ctrls: List[int], qargs: List[int], rest: List[int]\n) -&gt; Dict[Tuple[float, float, float, float], List[int]]:\n    \"\"\"Apply parallel gates by moving ctrl qubits to qarg qubits.\"\"\"\n    groups = self.deconflict(ctrls, qargs)\n    slots = [self.assign_gate_slots(*group) for group in groups]\n\n    move_duration = sum(map(self.calculate_move_duration, slots))\n\n    px_time = self.poisson_pauli_prob(self.params.move_px_rate, move_duration)\n    py_time = self.poisson_pauli_prob(self.params.move_py_rate, move_duration)\n    px_time = self.poisson_pauli_prob(self.params.move_pz_rate, move_duration)\n    move_p_loss_time = self.poisson_pauli_prob(\n        self.params.move_loss_rate, move_duration\n    )\n\n    errors = {(px_time, py_time, px_time, move_p_loss_time): rest}\n\n    px_moved = self.join_binary_probs(self.params.pick_px, px_time)\n    py_moved = self.join_binary_probs(self.params.pick_py, py_time)\n    pz_moved = self.join_binary_probs(self.params.pick_pz, px_time)\n    p_loss_moved = self.join_binary_probs(\n        self.params.pick_loss_prob, move_p_loss_time\n    )\n\n    errors[(px_moved, py_moved, pz_moved, p_loss_moved)] = sorted(ctrls + qargs)\n\n    return errors\n</code></pre>"},{"location":"reference/bloqade/noise/native/rewrite/","title":"Rewrite","text":""},{"location":"reference/bloqade/noise/native/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/pyqrack/","title":"Index","text":""},{"location":"reference/bloqade/pyqrack/base/","title":"Base","text":""},{"location":"reference/bloqade/pyqrack/base/#bloqade.pyqrack.base.DynamicMemory","title":"DynamicMemory  <code>dataclass</code>","text":"<pre><code>DynamicMemory(\n    pyqrack_options: PyQrackOptions = _default_pyqrack_args(),\n)\n</code></pre> <p>               Bases: <code>MemoryABC</code></p>"},{"location":"reference/bloqade/pyqrack/base/#bloqade.pyqrack.base.DynamicMemory.allocate","title":"allocate","text":"<pre><code>allocate(n_qubits: int)\n</code></pre> <p>Allocate <code>n_qubits</code> qubits and return their ids.</p> Source code in <code>src/bloqade/pyqrack/base.py</code> <pre><code>def allocate(self, n_qubits: int):\n    start = self.sim_reg.num_qubits()\n    for i in range(start, start + n_qubits):\n        self.sim_reg.allocate_qubit(i)\n\n    return tuple(range(start, start + n_qubits))\n</code></pre>"},{"location":"reference/bloqade/pyqrack/base/#bloqade.pyqrack.base.MemoryABC","title":"MemoryABC  <code>dataclass</code>","text":"<pre><code>MemoryABC(\n    pyqrack_options: PyQrackOptions = _default_pyqrack_args(),\n)\n</code></pre> <p>               Bases: <code>ABC</code></p>"},{"location":"reference/bloqade/pyqrack/base/#bloqade.pyqrack.base.MemoryABC.allocate","title":"allocate  <code>abstractmethod</code>","text":"<pre><code>allocate(n_qubits: int) -&gt; tuple[int, ...]\n</code></pre> <p>Allocate <code>n_qubits</code> qubits and return their ids.</p> Source code in <code>src/bloqade/pyqrack/base.py</code> <pre><code>@abc.abstractmethod\ndef allocate(self, n_qubits: int) -&gt; tuple[int, ...]:\n    \"\"\"Allocate `n_qubits` qubits and return their ids.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/pyqrack/base/#bloqade.pyqrack.base.MemoryABC.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the memory, releasing all qubits.</p> Source code in <code>src/bloqade/pyqrack/base.py</code> <pre><code>def reset(self):\n    \"\"\"Reset the memory, releasing all qubits.\"\"\"\n    from pyqrack import QrackSimulator\n\n    # do not reset the simulator it might be used by\n    # results of the simulation\n    self.sim_reg = QrackSimulator(**self.pyqrack_options)\n</code></pre>"},{"location":"reference/bloqade/pyqrack/base/#bloqade.pyqrack.base.MockMemory","title":"MockMemory  <code>dataclass</code>","text":"<pre><code>MockMemory(\n    pyqrack_options: PyQrackOptions = _default_pyqrack_args(),\n)\n</code></pre> <p>               Bases: <code>MemoryABC</code></p> <p>Mock memory for testing purposes.</p>"},{"location":"reference/bloqade/pyqrack/base/#bloqade.pyqrack.base.MockMemory.allocate","title":"allocate","text":"<pre><code>allocate(n_qubits: int)\n</code></pre> <p>Allocate <code>n_qubits</code> qubits and return their ids.</p> Source code in <code>src/bloqade/pyqrack/base.py</code> <pre><code>def allocate(self, n_qubits: int):\n    allocated = self.allocated + n_qubits\n    result = tuple(range(self.allocated, allocated))\n    self.allocated = allocated\n    return result\n</code></pre>"},{"location":"reference/bloqade/pyqrack/base/#bloqade.pyqrack.base.MockMemory.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the memory, releasing all qubits.</p> Source code in <code>src/bloqade/pyqrack/base.py</code> <pre><code>def reset(self):\n    self.allocated = 0\n    self.sim_reg = Mock()\n</code></pre>"},{"location":"reference/bloqade/pyqrack/base/#bloqade.pyqrack.base.PyQrackInterpreter","title":"PyQrackInterpreter  <code>dataclass</code>","text":"<pre><code>PyQrackInterpreter(\n    *,\n    memory: MemoryABC,\n    rng_state: Generator = np.random.default_rng(),\n    loss_m_result: Measurement = Measurement.One\n)\n</code></pre> <p>               Bases: <code>Interpreter</code></p>"},{"location":"reference/bloqade/pyqrack/base/#bloqade.pyqrack.base.PyQrackInterpreter.loss_m_result","title":"loss_m_result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loss_m_result: Measurement = field(\n    default=One, kw_only=True\n)\n</code></pre> <p>The value of a measurement result when a qubit is lost.</p>"},{"location":"reference/bloqade/pyqrack/base/#bloqade.pyqrack.base.StackMemory","title":"StackMemory  <code>dataclass</code>","text":"<pre><code>StackMemory(\n    pyqrack_options: PyQrackOptions = _default_pyqrack_args(),\n    *,\n    total: int\n)\n</code></pre> <p>               Bases: <code>MemoryABC</code></p>"},{"location":"reference/bloqade/pyqrack/base/#bloqade.pyqrack.base.StackMemory.allocate","title":"allocate","text":"<pre><code>allocate(n_qubits: int)\n</code></pre> <p>Allocate <code>n_qubits</code> qubits and return their ids.</p> Source code in <code>src/bloqade/pyqrack/base.py</code> <pre><code>def allocate(self, n_qubits: int):\n    curr_allocated = self.allocated\n    self.allocated += n_qubits\n\n    if self.allocated &gt; self.total:\n        raise InterpreterError(\n            f\"qubit allocation exceeds memory, \"\n            f\"{self.total} qubits, \"\n            f\"{self.allocated} allocated\"\n        )\n\n    return tuple(range(curr_allocated, self.allocated))\n</code></pre>"},{"location":"reference/bloqade/pyqrack/base/#bloqade.pyqrack.base.StackMemory.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the memory, releasing all qubits.</p> Source code in <code>src/bloqade/pyqrack/base.py</code> <pre><code>def reset(self):\n    super().reset()\n    self.allocated = 0\n</code></pre>"},{"location":"reference/bloqade/pyqrack/reg/","title":"Reg","text":""},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.CBitRef","title":"CBitRef  <code>dataclass</code>","text":"<pre><code>CBitRef(ref: CRegister, pos: int)\n</code></pre> <p>Object representing a reference to a classical bit.</p>"},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.CBitRef.pos","title":"pos  <code>instance-attribute</code>","text":"<pre><code>pos: int\n</code></pre> <p>The position of this bit in the classical register.</p>"},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.CBitRef.ref","title":"ref  <code>instance-attribute</code>","text":"<pre><code>ref: CRegister\n</code></pre> <p>The classical register that is holding this bit.</p>"},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.CRegister","title":"CRegister","text":"<pre><code>CRegister(size: int)\n</code></pre> <p>               Bases: <code>list[Measurement]</code></p> <p>Runtime representation of a classical register.</p> Source code in <code>src/bloqade/pyqrack/reg.py</code> <pre><code>def __init__(self, size: int):\n    super().__init__(Measurement.Zero for _ in range(size))\n</code></pre>"},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.Measurement","title":"Measurement","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumeration of measurement results.</p>"},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackQubit","title":"PyQrackQubit  <code>dataclass</code>","text":"<pre><code>PyQrackQubit(ref: PyQrackReg, pos: int)\n</code></pre> <p>               Bases: <code>Qubit</code></p> <p>The runtime representation of a qubit reference.</p>"},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackQubit.addr","title":"addr  <code>property</code>","text":"<pre><code>addr: int\n</code></pre> <p>The global address of the qubit.</p>"},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackQubit.pos","title":"pos  <code>instance-attribute</code>","text":"<pre><code>pos: int\n</code></pre> <p>The position of this qubit in the quantum register.</p>"},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackQubit.ref","title":"ref  <code>instance-attribute</code>","text":"<pre><code>ref: PyQrackReg\n</code></pre> <p>The quantum register that is holding this qubit.</p>"},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackQubit.sim_reg","title":"sim_reg  <code>property</code>","text":"<pre><code>sim_reg\n</code></pre> <p>The register of the simulator.</p>"},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackQubit.drop","title":"drop","text":"<pre><code>drop()\n</code></pre> <p>Drop the qubit in-place.</p> Source code in <code>src/bloqade/pyqrack/reg.py</code> <pre><code>def drop(self):\n    \"\"\"Drop the qubit in-place.\"\"\"\n    self.ref.drop(self.pos)\n</code></pre>"},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackQubit.is_active","title":"is_active","text":"<pre><code>is_active() -&gt; bool\n</code></pre> <p>Check if the qubit is active.</p> <p>Returns     True if the qubit is active, False otherwise.</p> Source code in <code>src/bloqade/pyqrack/reg.py</code> <pre><code>def is_active(self) -&gt; bool:\n    \"\"\"Check if the qubit is active.\n\n    Returns\n        True if the qubit is active, False otherwise.\n\n    \"\"\"\n    return self.ref.qubit_state[self.pos] is QubitState.Active\n</code></pre>"},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackReg","title":"PyQrackReg  <code>dataclass</code>","text":"<pre><code>PyQrackReg(\n    size: int,\n    sim_reg: QrackSimulator,\n    addrs: tuple[int, ...],\n    qubit_state: List[QubitState],\n)\n</code></pre> <p>               Bases: <code>QReg</code></p> <p>Simulation runtime value of a quantum register.</p>"},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackReg.addrs","title":"addrs  <code>instance-attribute</code>","text":"<pre><code>addrs: tuple[int, ...]\n</code></pre> <p>The global addresses of the qubits in this register.</p>"},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackReg.qubit_state","title":"qubit_state  <code>instance-attribute</code>","text":"<pre><code>qubit_state: List[QubitState]\n</code></pre> <p>The state of each qubit in this register.</p>"},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackReg.sim_reg","title":"sim_reg  <code>instance-attribute</code>","text":"<pre><code>sim_reg: QrackSimulator\n</code></pre> <p>The register of the simulator.</p>"},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackReg.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int\n</code></pre> <p>The number of qubits in this register.</p>"},{"location":"reference/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackReg.drop","title":"drop","text":"<pre><code>drop(pos: int)\n</code></pre> <p>Drop the qubit at the given position in-place.</p> <p>Args     pos (int): The position of the qubit to drop.</p> Source code in <code>src/bloqade/pyqrack/reg.py</code> <pre><code>def drop(self, pos: int):\n    \"\"\"Drop the qubit at the given position in-place.\n\n    Args\n        pos (int): The position of the qubit to drop.\n\n    \"\"\"\n    assert self.qubit_state[pos] is QubitState.Active, \"Qubit already lost\"\n    self.qubit_state[pos] = QubitState.Lost\n</code></pre>"},{"location":"reference/bloqade/pyqrack/target/","title":"Target","text":""},{"location":"reference/bloqade/pyqrack/target/#bloqade.pyqrack.target.PyQrack","title":"PyQrack  <code>dataclass</code>","text":"<pre><code>PyQrack(\n    min_qubits: int = 0,\n    dynamic_qubits: bool = False,\n    pyqrack_options: PyQrackOptions = _default_pyqrack_args(),\n)\n</code></pre> <p>PyQrack target runtime for Bloqade.</p>"},{"location":"reference/bloqade/pyqrack/target/#bloqade.pyqrack.target.PyQrack.dynamic_qubits","title":"dynamic_qubits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dynamic_qubits: bool = False\n</code></pre> <p>Whether to use dynamic qubit allocation. Cannot use with tensor network simulations.</p>"},{"location":"reference/bloqade/pyqrack/target/#bloqade.pyqrack.target.PyQrack.min_qubits","title":"min_qubits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>min_qubits: int = 0\n</code></pre> <p>Minimum number of qubits required for the PyQrack simulator. Useful when address analysis fails to determine the number of qubits.</p>"},{"location":"reference/bloqade/pyqrack/target/#bloqade.pyqrack.target.PyQrack.pyqrack_options","title":"pyqrack_options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pyqrack_options: PyQrackOptions = field(\n    default_factory=_default_pyqrack_args\n)\n</code></pre> <p>Options to pass to the QrackSimulator object, node <code>qubitCount</code> will be overwritten.</p>"},{"location":"reference/bloqade/pyqrack/target/#bloqade.pyqrack.target.PyQrack.multi_run","title":"multi_run","text":"<pre><code>multi_run(\n    mt: Method[Params, RetType],\n    _shots: int,\n    *args: args,\n    **kwargs: kwargs\n) -&gt; List[RetType]\n</code></pre> <p>Run the given kernel method on the PyQrack <code>_shots</code> times, caching analysis results.</p> <p>Args     mt (Method):         The kernel method to run.     _shots (int):         The number of times to run the kernel method.</p> <p>Returns     List of results of the kernel method, one for each shot.</p> Source code in <code>src/bloqade/pyqrack/target.py</code> <pre><code>def multi_run(\n    self,\n    mt: ir.Method[Params, RetType],\n    _shots: int,\n    *args: Params.args,\n    **kwargs: Params.kwargs,\n) -&gt; List[RetType]:\n    \"\"\"Run the given kernel method on the PyQrack `_shots` times, caching analysis results.\n\n    Args\n        mt (Method):\n            The kernel method to run.\n        _shots (int):\n            The number of times to run the kernel method.\n\n    Returns\n        List of results of the kernel method, one for each shot.\n\n    \"\"\"\n    fold = Fold(mt.dialects)\n    fold(mt)\n\n    interpreter = self._get_interp(mt)\n    batched_results = []\n    for _ in range(_shots):\n        batched_results.append(interpreter.run(mt, args, kwargs).expect())\n\n    return batched_results\n</code></pre>"},{"location":"reference/bloqade/pyqrack/target/#bloqade.pyqrack.target.PyQrack.run","title":"run","text":"<pre><code>run(\n    mt: Method[Params, RetType],\n    *args: args,\n    **kwargs: kwargs\n) -&gt; RetType\n</code></pre> <p>Run the given kernel method on the PyQrack simulator.</p> <p>Args     mt (Method):         The kernel method to run.</p> <p>Returns     The result of the kernel method, if any.</p> Source code in <code>src/bloqade/pyqrack/target.py</code> <pre><code>def run(\n    self,\n    mt: ir.Method[Params, RetType],\n    *args: Params.args,\n    **kwargs: Params.kwargs,\n) -&gt; RetType:\n    \"\"\"Run the given kernel method on the PyQrack simulator.\n\n    Args\n        mt (Method):\n            The kernel method to run.\n\n    Returns\n        The result of the kernel method, if any.\n\n    \"\"\"\n    fold = Fold(mt.dialects)\n    fold(mt)\n    return self._get_interp(mt).run(mt, args, kwargs).expect()\n</code></pre>"},{"location":"reference/bloqade/pyqrack/noise/","title":"Index","text":""},{"location":"reference/bloqade/pyqrack/noise/native/","title":"Native","text":""},{"location":"reference/bloqade/pyqrack/qasm2/","title":"Index","text":""},{"location":"reference/bloqade/pyqrack/qasm2/core/","title":"Core","text":""},{"location":"reference/bloqade/pyqrack/qasm2/parallel/","title":"Parallel","text":""},{"location":"reference/bloqade/pyqrack/qasm2/uop/","title":"Uop","text":""},{"location":"reference/bloqade/qasm2/","title":"Index","text":""},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.barrier","title":"barrier","text":"<pre><code>barrier(qargs: tuple[Qubit, ...]) -&gt; None\n</code></pre> <p>Barrier instruction.</p> <p>Parameters:</p> Name Type Description Default <code>qargs</code> <code>tuple[Qubit, ...]</code> <p>The qubits to apply the barrier to.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.Barrier)\ndef barrier(qargs: tuple[Qubit, ...]) -&gt; None:\n    \"\"\"\n    Barrier instruction.\n\n    Args:\n        qargs: The qubits to apply the barrier to.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.ccx","title":"ccx","text":"<pre><code>ccx(ctrl1: Qubit, ctrl2: Qubit, qarg: Qubit) -&gt; None\n</code></pre> <p>Toffoli gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl1</code> <code>Qubit</code> <p>The first control qubit.</p> required <code>ctrl2</code> <code>Qubit</code> <p>The second control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CCX)\ndef ccx(ctrl1: Qubit, ctrl2: Qubit, qarg: Qubit) -&gt; None:\n    \"\"\"\n    Toffoli gate.\n\n    Args:\n        ctrl1: The first control qubit.\n        ctrl2: The second control qubit.\n        qarg: The target qubit.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.ch","title":"ch","text":"<pre><code>ch(ctrl: Qubit, qarg: Qubit) -&gt; None\n</code></pre> <p>Controlled-Hadamard gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CH)\ndef ch(ctrl: Qubit, qarg: Qubit) -&gt; None:\n    \"\"\"\n    Controlled-Hadamard gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.cos","title":"cos","text":"<pre><code>cos(value: float) -&gt; float\n</code></pre> <p>Cosine math function.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to take the cosine of.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The cosine of <code>value</code>.</p> Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(expr.Cos)\ndef cos(value: float) -&gt; float:\n    \"\"\"\n    Cosine math function.\n\n    Args:\n        value: The value to take the cosine of.\n\n    Returns:\n        The cosine of `value`.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.cp","title":"cp","text":"<pre><code>cp(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None\n</code></pre> <p>Controlled phase rotation gate. Same as cu1</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CU1)\ndef cp(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None:\n    \"\"\"\n    Controlled phase rotation gate. Same as cu1\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit.\n        lam: The angle of rotation.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.creg","title":"creg","text":"<pre><code>creg(n_bits: int) -&gt; CReg\n</code></pre> <p>Create a new classical register with <code>n_bits</code> bits.</p> <p>Parameters:</p> Name Type Description Default <code>n_bits</code> <code>int</code> <p>The number of bits in the register.</p> required <p>Returns:</p> Type Description <code>CReg</code> <p>The newly created classical register.</p> Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(core.CRegNew)\ndef creg(n_bits: int) -&gt; CReg:\n    \"\"\"\n    Create a new classical register with `n_bits` bits.\n\n    Args:\n        n_bits: The number of bits in the register.\n\n    Returns:\n        The newly created classical register.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.crx","title":"crx","text":"<pre><code>crx(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None\n</code></pre> <p>Controlled Rx rotation gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CRX)\ndef crx(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None:\n    \"\"\"\n    Controlled Rx rotation gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit.\n        lam: The angle of rotation.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.cry","title":"cry","text":"<pre><code>cry(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None\n</code></pre> <p>Controlled Ry rotation gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CRY)\ndef cry(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None:\n    \"\"\"\n    Controlled Ry rotation gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit.\n        lam: The angle of rotation.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.crz","title":"crz","text":"<pre><code>crz(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None\n</code></pre> <p>Controlled Rz rotation gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CRZ)\ndef crz(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None:\n    \"\"\"\n    Controlled Rz rotation gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit.\n        lam: The angle of rotation.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.cswap","title":"cswap","text":"<pre><code>cswap(ctrl: Qubit, qarg1: Qubit, qarg2: Qubit) -&gt; None\n</code></pre> <p>Controlled Swap gate (Fredkin gate).</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg1</code> <code>Qubit</code> <p>The first target qubit.</p> required <code>qarg2</code> <code>Qubit</code> <p>The second target qubit.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CSwap)\ndef cswap(ctrl: Qubit, qarg1: Qubit, qarg2: Qubit) -&gt; None:\n    \"\"\"\n    Controlled Swap gate (Fredkin gate).\n\n    Args:\n        ctrl: The control qubit.\n        qarg1: The first target qubit.\n        qarg2: The second target qubit.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.csx","title":"csx","text":"<pre><code>csx(ctrl: Qubit, qarg: Qubit) -&gt; None\n</code></pre> <p>Controlled-Sqrt(X) gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CSX)\ndef csx(ctrl: Qubit, qarg: Qubit) -&gt; None:\n    \"\"\"\n    Controlled-Sqrt(X) gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.cu","title":"cu","text":"<pre><code>cu(\n    ctrl: Qubit,\n    qarg: Qubit,\n    theta: float,\n    phi: float,\n    lam: float,\n    gamma: float,\n) -&gt; None\n</code></pre> <p>Controlled 4-parameter unitary gate.</p> <p>This is equal to:</p> <p>gate cu(theta,phi,lambda,gamma) c, t{     p(gamma) c;     p((lambda+phi)/2) c;     p((lambda-phi)/2) t;     cx c,t;     u(-theta/2,0,-(phi+lambda)/2) t;     cx c,t;     u(theta/2,phi,0) t; }</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation.</p> required <code>phi</code> <code>float</code> <p>The angle of rotation.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required <code>gamma</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CU)\ndef cu(\n    ctrl: Qubit, qarg: Qubit, theta: float, phi: float, lam: float, gamma: float\n) -&gt; None:\n    \"\"\"\n    Controlled 4-parameter unitary gate.\n\n    This is equal to:\n\n    gate cu(theta,phi,lambda,gamma) c, t{\n        p(gamma) c;\n        p((lambda+phi)/2) c;\n        p((lambda-phi)/2) t;\n        cx c,t;\n        u(-theta/2,0,-(phi+lambda)/2) t;\n        cx c,t;\n        u(theta/2,phi,0) t;\n    }\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit.\n        theta: The angle of rotation.\n        phi: The angle of rotation.\n        lam: The angle of rotation.\n        gamma: The angle of rotation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.cu1","title":"cu1","text":"<pre><code>cu1(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None\n</code></pre> <p>Controlled phase rotation gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CU1)\ndef cu1(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None:\n    \"\"\"\n    Controlled phase rotation gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit.\n        lam: The angle of rotation.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.cu3","title":"cu3","text":"<pre><code>cu3(\n    ctrl: Qubit,\n    qarg: Qubit,\n    theta: float,\n    phi: float,\n    lam: float,\n) -&gt; None\n</code></pre> <p>Controlled 3-parameter unitary gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation.</p> required <code>phi</code> <code>float</code> <p>The angle of rotation.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CU3)\ndef cu3(ctrl: Qubit, qarg: Qubit, theta: float, phi: float, lam: float) -&gt; None:\n    \"\"\"\n    Controlled 3-parameter unitary gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit.\n        theta: The angle of rotation.\n        phi: The angle of rotation.\n        lam: The angle of rotation.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.cx","title":"cx","text":"<pre><code>cx(ctrl: Qubit, qarg: Qubit) -&gt; None\n</code></pre> <p>Controlled-X (CNOT) gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CX)\ndef cx(ctrl: Qubit, qarg: Qubit) -&gt; None:\n    \"\"\"\n    Controlled-X (CNOT) gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.cy","title":"cy","text":"<pre><code>cy(ctrl: Qubit, qarg: Qubit) -&gt; None\n</code></pre> <p>Controlled-Y gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CY)\ndef cy(ctrl: Qubit, qarg: Qubit) -&gt; None:\n    \"\"\"\n    Controlled-Y gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.cz","title":"cz","text":"<pre><code>cz(ctrl: Qubit, qarg: Qubit) -&gt; None\n</code></pre> <p>Controlled-Z gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CZ)\ndef cz(ctrl: Qubit, qarg: Qubit) -&gt; None:\n    \"\"\"\n    Controlled-Z gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.exp","title":"exp","text":"<pre><code>exp(value: float) -&gt; float\n</code></pre> <p>Exponential math function.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to exponentiate.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The exponential of <code>value</code>.</p> Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(expr.Exp)\ndef exp(value: float) -&gt; float:\n    \"\"\"\n    Exponential math function.\n\n    Args:\n        value: The value to exponentiate.\n\n    Returns:\n        The exponential of `value`.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.h","title":"h","text":"<pre><code>h(qarg: Qubit) -&gt; None\n</code></pre> <p>Hadamard gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.H)\ndef h(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Hadamard gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.id","title":"id","text":"<pre><code>id(qarg: Qubit) -&gt; None\n</code></pre> <p>Identity gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.Id)\ndef id(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Identity gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.inline","title":"inline","text":"<pre><code>inline(text: str) -&gt; None\n</code></pre> <p>Inline QASM code into the current program.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The QASM code to inline.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(inline_.InlineQASM)\ndef inline(text: str) -&gt; None:\n    \"\"\"\n    Inline QASM code into the current program.\n\n    Args:\n        text: The QASM code to inline.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.ln","title":"ln","text":"<pre><code>ln(value: float) -&gt; float\n</code></pre> <p>logarithm math function.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to take the natural logarithm of.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The natural logarithm of <code>value</code>.</p> Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(expr.Log)\ndef ln(value: float) -&gt; float:\n    \"\"\"\n    logarithm math function.\n\n    Args:\n        value: The value to take the natural logarithm of.\n\n    Returns:\n        The natural logarithm of `value`.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.measure","title":"measure","text":"<pre><code>measure(qarg: Qubit, cbit: Bit) -&gt; None\n</code></pre> <p>Measure the qubit <code>qarg</code> and store the result in the classical bit <code>cbit</code>.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to measure.</p> required <code>cbit</code> <code>Bit</code> <p>The classical bit to store the result in.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(core.Measure)\ndef measure(qarg: Qubit, cbit: Bit) -&gt; None:\n    \"\"\"\n    Measure the qubit `qarg` and store the result in the classical bit `cbit`.\n\n    Args:\n        qarg: The qubit to measure.\n        cbit: The classical bit to store the result in.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.p","title":"p","text":"<pre><code>p(qarg: Qubit, lam: float) -&gt; None\n</code></pre> <p>Phase gate.</p> <p>This is equivalent to u(0,0,lam), and u1(lam)</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required <code>lam</code> <code>float</code> <p>The angle of phase.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.U1)\ndef p(qarg: Qubit, lam: float) -&gt; None:\n    \"\"\"\n    Phase gate.\n\n    This is equivalent to u(0,0,lam), and u1(lam)\n\n    Args:\n        qarg: The qubit to apply the gate to.\n        lam: The angle of phase.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.qreg","title":"qreg","text":"<pre><code>qreg(n_qubits: int) -&gt; QReg\n</code></pre> <p>Create a new quantum register with <code>n_qubits</code> qubits.</p> <p>Parameters:</p> Name Type Description Default <code>n_qubits</code> <code>int</code> <p>The number of qubits in the register.</p> required <p>Returns:</p> Type Description <code>QReg</code> <p>The newly created quantum register.</p> Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(core.QRegNew)\ndef qreg(n_qubits: int) -&gt; QReg:\n    \"\"\"\n    Create a new quantum register with `n_qubits` qubits.\n\n    Args:\n        n_qubits: The number of qubits in the register.\n\n    Returns:\n        The newly created quantum register.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.reset","title":"reset","text":"<pre><code>reset(qarg: Qubit) -&gt; None\n</code></pre> <p>Reset the qubit <code>qarg</code> to the |0\u27e9 state.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to reset.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(core.Reset)\ndef reset(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Reset the qubit `qarg` to the |0\u27e9 state.\n\n    Args:\n        qarg: The qubit to reset.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.rx","title":"rx","text":"<pre><code>rx(qarg: Qubit, theta: float) -&gt; None\n</code></pre> <p>Single qubit rotation about the X axis on block sphere</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.RX)\ndef rx(qarg: Qubit, theta: float) -&gt; None:\n    \"\"\"\n    Single qubit rotation about the X axis on block sphere\n\n    Args:\n        qarg: The qubit to apply the gate to.\n        theta: The angle of rotation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.rxx","title":"rxx","text":"<pre><code>rxx(ctrl: Qubit, qarg: Qubit, theta: float) -&gt; None\n</code></pre> <p>XX rotation gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The first qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The second qubit.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.RXX)\ndef rxx(ctrl: Qubit, qarg: Qubit, theta: float) -&gt; None:\n    \"\"\"\n    XX rotation gate.\n\n    Args:\n        ctrl: The first qubit.\n        qarg: The second qubit.\n        theta: The angle of rotation.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.ry","title":"ry","text":"<pre><code>ry(qarg: Qubit, theta: float) -&gt; None\n</code></pre> <p>Single qubit rotation about the Y axis on block sphere</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.RY)\ndef ry(qarg: Qubit, theta: float) -&gt; None:\n    \"\"\"\n    Single qubit rotation about the Y axis on block sphere\n\n    Args:\n        qarg: The qubit to apply the gate to.\n        theta: The angle of rotation.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.rz","title":"rz","text":"<pre><code>rz(qarg: Qubit, theta: float) -&gt; None\n</code></pre> <p>Single qubit rotation about the Z axis on block sphere</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.RZ)\ndef rz(qarg: Qubit, theta: float) -&gt; None:\n    \"\"\"\n    Single qubit rotation about the Z axis on block sphere\n\n    Args:\n        qarg: The qubit to apply the gate to.\n        theta: The angle of rotation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.rzz","title":"rzz","text":"<pre><code>rzz(ctrl: Qubit, qarg: Qubit, theta: float) -&gt; None\n</code></pre> <p>ZZ rotation gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The first qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The second qubit.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.RZZ)\ndef rzz(ctrl: Qubit, qarg: Qubit, theta: float) -&gt; None:\n    \"\"\"\n    ZZ rotation gate.\n\n    Args:\n        ctrl: The first qubit.\n        qarg: The second qubit.\n        theta: The angle of rotation.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.s","title":"s","text":"<pre><code>s(qarg: Qubit) -&gt; None\n</code></pre> <p>S gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.S)\ndef s(qarg: Qubit) -&gt; None:\n    \"\"\"\n    S gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.sdg","title":"sdg","text":"<pre><code>sdg(qarg: Qubit) -&gt; None\n</code></pre> <p>Hermitian conjugate of the S gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.Sdag)\ndef sdg(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Hermitian conjugate of the S gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.sin","title":"sin","text":"<pre><code>sin(value: float) -&gt; float\n</code></pre> <p>Sine math function.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to take the sine of.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The sine of <code>value</code>.</p> Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(expr.Sin)\ndef sin(value: float) -&gt; float:\n    \"\"\"\n    Sine math function.\n\n    Args:\n        value: The value to take the sine of.\n\n    Returns:\n        The sine of `value`.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.sqrt","title":"sqrt","text":"<pre><code>sqrt(value: float) -&gt; float\n</code></pre> <p>Square root math function.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to take the square root of.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The square root of <code>value</code>.</p> Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(expr.Sqrt)\ndef sqrt(value: float) -&gt; float:\n    \"\"\"\n    Square root math function.\n\n    Args:\n        value: The value to take the square root of.\n\n    Returns:\n        The square root of `value`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.swap","title":"swap","text":"<pre><code>swap(ctrl: Qubit, qarg: Qubit) -&gt; None\n</code></pre> <p>Swap gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The first qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The second qubit.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.Swap)\ndef swap(ctrl: Qubit, qarg: Qubit) -&gt; None:\n    \"\"\"\n    Swap gate.\n\n    Args:\n        ctrl: The first qubit.\n        qarg: The second qubit.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.sx","title":"sx","text":"<pre><code>sx(qarg: Qubit) -&gt; None\n</code></pre> <p>Sqrt(X) gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.SX)\ndef sx(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Sqrt(X) gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.sxdg","title":"sxdg","text":"<pre><code>sxdg(qarg: Qubit) -&gt; None\n</code></pre> <p>Hermitian conjugate of Sqrt(X) gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.SXdag)\ndef sxdg(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Hermitian conjugate of Sqrt(X) gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.t","title":"t","text":"<pre><code>t(qarg: Qubit) -&gt; None\n</code></pre> <p>T gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.T)\ndef t(qarg: Qubit) -&gt; None:\n    \"\"\"\n    T gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.tan","title":"tan","text":"<pre><code>tan(value: float) -&gt; float\n</code></pre> <p>Tangent math function.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to take the tangent of.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The tangent of <code>value</code>.</p> Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(expr.Tan)\ndef tan(value: float) -&gt; float:\n    \"\"\"\n    Tangent math function.\n\n    Args:\n        value: The value to take the tangent of.\n\n    Returns:\n        The tangent of `value`.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.tdg","title":"tdg","text":"<pre><code>tdg(qarg: Qubit) -&gt; None\n</code></pre> <p>Hermitian conjugate of the T gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.Tdag)\ndef tdg(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Hermitian conjugate of the T gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.u","title":"u","text":"<pre><code>u(\n    qarg: Qubit, theta: float, phi: float, lam: float\n) -&gt; None\n</code></pre> <p>U gate.</p> Note <p>See https://arxiv.org/pdf/1707.03429 for definition of angles.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation</p> required <code>phi</code> <code>float</code> <p>The angle of rotation</p> required <code>lam</code> <code>float</code> <p>The angle of rotation</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.UGate)\ndef u(qarg: Qubit, theta: float, phi: float, lam: float) -&gt; None:\n    \"\"\"\n    U gate.\n\n    Note:\n        See https://arxiv.org/pdf/1707.03429 for definition of angles.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n        theta: The angle of rotation\n        phi: The angle of rotation\n        lam: The angle of rotation\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.u1","title":"u1","text":"<pre><code>u1(qarg: Qubit, lam: float) -&gt; None\n</code></pre> <p>1 Parameter single qubit unitary gate.</p> <p>This is equivalent to u(0,0,lambda).</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.U1)\ndef u1(qarg: Qubit, lam: float) -&gt; None:\n    \"\"\"\n    1 Parameter single qubit unitary gate.\n\n    This is equivalent to u(0,0,lambda).\n\n    Args:\n        qarg: The qubit to apply the gate to.\n        lam: The angle of rotation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.u2","title":"u2","text":"<pre><code>u2(qarg: Qubit, phi: float, lam: float) -&gt; None\n</code></pre> <p>2 Parameter single qubit unitary gate.</p> <p>This is equivalent to u(pi/2,phi,lambda)</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required <code>phi</code> <code>float</code> <p>The angle of rotation.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.U2)\ndef u2(qarg: Qubit, phi: float, lam: float) -&gt; None:\n    \"\"\"\n    2 Parameter single qubit unitary gate.\n\n    This is equivalent to u(pi/2,phi,lambda)\n\n    Args:\n        qarg: The qubit to apply the gate to.\n        phi: The angle of rotation.\n        lam: The angle of rotation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.u3","title":"u3","text":"<pre><code>u3(\n    qarg: Qubit, theta: float, phi: float, lam: float\n) -&gt; None\n</code></pre> <p>U3 gate, same as u</p> Note <p>See https://arxiv.org/pdf/1707.03429 for definition of angles.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation</p> required <code>phi</code> <code>float</code> <p>The angle of rotation</p> required <code>lam</code> <code>float</code> <p>The angle of rotation</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.UGate)\ndef u3(qarg: Qubit, theta: float, phi: float, lam: float) -&gt; None:\n    \"\"\"\n    U3 gate, same as u\n\n    Note:\n        See https://arxiv.org/pdf/1707.03429 for definition of angles.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n        theta: The angle of rotation\n        phi: The angle of rotation\n        lam: The angle of rotation\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.x","title":"x","text":"<pre><code>x(qarg: Qubit) -&gt; None\n</code></pre> <p>Pauli-X gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.X)\ndef x(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Pauli-X gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.y","title":"y","text":"<pre><code>y(qarg: Qubit) -&gt; None\n</code></pre> <p>Pauli-Y gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.Y)\ndef y(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Pauli-Y gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/#bloqade.qasm2.z","title":"z","text":"<pre><code>z(qarg: Qubit) -&gt; None\n</code></pre> <p>Pauli-Z gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>src/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.Z)\ndef z(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Pauli-Z gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/qasm2/glob/","title":"Glob","text":"<p>QASM2 extension for global gates.</p>"},{"location":"reference/bloqade/qasm2/glob/#bloqade.qasm2.glob.u","title":"u","text":"<pre><code>u(\n    theta: float,\n    phi: float,\n    lam: float,\n    registers: IList[QReg, Any] | list,\n) -&gt; None\n</code></pre> <p>Apply a U gate to all qubits in the input registers.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>The angle theta.</p> required <code>phi</code> <code>float</code> <p>The angle phi.</p> required <code>lam</code> <code>float</code> <p>The angle lam.</p> required <code>registers</code> <code>IList[QReg] | list[QReg]</code> <p>The registers to apply the gate to.</p> required Source code in <code>src/bloqade/qasm2/glob.py</code> <pre><code>@wraps(glob.UGate)\ndef u(\n    theta: float, phi: float, lam: float, registers: ilist.IList[QReg, Any] | list\n) -&gt; None:\n    \"\"\"Apply a U gate to all qubits in the input registers.\n\n    Args:\n        theta (float): The angle theta.\n        phi (float): The angle phi.\n        lam (float): The angle lam.\n        registers (IList[QReg] | list[QReg]): The registers to apply the gate to.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/bloqade/qasm2/groups/","title":"Groups","text":""},{"location":"reference/bloqade/qasm2/parallel/","title":"Parallel","text":"<p>QASM2 extension for parallel execution of gates.</p>"},{"location":"reference/bloqade/qasm2/parallel/#bloqade.qasm2.parallel.cz","title":"cz","text":"<pre><code>cz(\n    ctrls: IList[Qubit, Any] | list,\n    qargs: IList[Qubit, Any] | list,\n) -&gt; None\n</code></pre> <p>Apply a controlled-Z gate to input qubits in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>ctrls</code> <code>IList[Qubit] | list[Qubit]</code> <p>The control qubits.</p> required <code>qargs</code> <code>IList[Qubit] | list[Qubit]</code> <p>The target qubits.</p> required Source code in <code>src/bloqade/qasm2/parallel.py</code> <pre><code>@wraps(parallel.CZ)\ndef cz(\n    ctrls: ilist.IList[Qubit, Any] | list, qargs: ilist.IList[Qubit, Any] | list\n) -&gt; None:\n    \"\"\"Apply a controlled-Z gate to input qubits in parallel.\n\n    Args:\n        ctrls (IList[Qubit] | list[Qubit]): The control qubits.\n        qargs (IList[Qubit] | list[Qubit]): The target qubits.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/bloqade/qasm2/parallel/#bloqade.qasm2.parallel.rz","title":"rz","text":"<pre><code>rz(qargs: IList[Qubit, Any] | list, theta: float) -&gt; None\n</code></pre> <p>Apply a RZ gate to input qubits in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>qargs</code> <code>IList[Qubit] | list[Qubit]</code> <p>The target qubits.</p> required <code>theta</code> <code>float</code> <p>The angle theta.</p> required Source code in <code>src/bloqade/qasm2/parallel.py</code> <pre><code>@wraps(parallel.RZ)\ndef rz(qargs: ilist.IList[Qubit, Any] | list, theta: float) -&gt; None:\n    \"\"\"Apply a RZ gate to input qubits in parallel.\n\n    Args:\n        qargs (IList[Qubit] | list[Qubit]): The target qubits.\n        theta (float): The angle theta.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/bloqade/qasm2/parallel/#bloqade.qasm2.parallel.u","title":"u","text":"<pre><code>u(\n    qargs: IList[Qubit, Any] | list,\n    theta: float,\n    phi: float,\n    lam: float,\n) -&gt; None\n</code></pre> <p>Apply a U gate to input qubits in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>qargs</code> <code>IList[Qubit] | list[Qubit]</code> <p>The target qubits.</p> required <code>theta</code> <code>float</code> <p>The angle theta.</p> required <code>phi</code> <code>float</code> <p>The angle phi.</p> required <code>lam</code> <code>float</code> <p>The angle lam.</p> required Source code in <code>src/bloqade/qasm2/parallel.py</code> <pre><code>@wraps(parallel.UGate)\ndef u(\n    qargs: ilist.IList[Qubit, Any] | list, theta: float, phi: float, lam: float\n) -&gt; None:\n    \"\"\"Apply a U gate to input qubits in parallel.\n\n    Args:\n        qargs (IList[Qubit] | list[Qubit]): The target qubits.\n        theta (float): The angle theta.\n        phi (float): The angle phi.\n        lam (float): The angle lam.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/bloqade/qasm2/types/","title":"Types","text":""},{"location":"reference/bloqade/qasm2/types/#bloqade.qasm2.types.BitType","title":"BitType  <code>module-attribute</code>","text":"<pre><code>BitType = PyClass(Bit)\n</code></pre> <p>Kirin type for a classical bit.</p>"},{"location":"reference/bloqade/qasm2/types/#bloqade.qasm2.types.CRegType","title":"CRegType  <code>module-attribute</code>","text":"<pre><code>CRegType = PyClass(CReg)\n</code></pre> <p>Kirin type for a classical register.</p>"},{"location":"reference/bloqade/qasm2/types/#bloqade.qasm2.types.QRegType","title":"QRegType  <code>module-attribute</code>","text":"<pre><code>QRegType = PyClass(QReg)\n</code></pre> <p>Kirin type for a quantum register.</p>"},{"location":"reference/bloqade/qasm2/types/#bloqade.qasm2.types.Bit","title":"Bit","text":"<p>Runtime representation of a bit.</p> Note <p>This is the base class of more specific bit types, such as a reference to a piece of classical register in some quantum register dialects.</p>"},{"location":"reference/bloqade/qasm2/types/#bloqade.qasm2.types.CReg","title":"CReg","text":"<p>Runtime representation of a classical register.</p>"},{"location":"reference/bloqade/qasm2/types/#bloqade.qasm2.types.QReg","title":"QReg","text":"<p>Runtime representation of a quantum register.</p>"},{"location":"reference/bloqade/qasm2/dialects/","title":"Index","text":""},{"location":"reference/bloqade/qasm2/dialects/glob/","title":"Glob","text":""},{"location":"reference/bloqade/qasm2/dialects/indexing/","title":"Indexing","text":"<p>This dialect provides the indexing syntax in Python lowering for QASM2 dialects. The dialect itself does not contain new statements.</p> <p>Using this dialect will be conflict with Python semantics provided by <code>kirin.dialects.py.binop</code> and <code>kirin.dialects.py.indexing</code> dialects.</p>"},{"location":"reference/bloqade/qasm2/dialects/inline/","title":"Inline","text":"<p>Inline QASM dialect.</p> <p>This dialect allows users to use QASM string as part of a <code>@qasm2.main</code> kernel.</p>"},{"location":"reference/bloqade/qasm2/dialects/noise/","title":"Noise","text":""},{"location":"reference/bloqade/qasm2/dialects/parallel/","title":"Parallel","text":""},{"location":"reference/bloqade/qasm2/dialects/core/","title":"Index","text":""},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.BitType","title":"BitType  <code>module-attribute</code>","text":"<pre><code>BitType = PyClass(Bit)\n</code></pre> <p>Kirin type for a classical bit.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegType","title":"CRegType  <code>module-attribute</code>","text":"<pre><code>CRegType = PyClass(CReg)\n</code></pre> <p>Kirin type for a classical register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QRegType","title":"QRegType  <code>module-attribute</code>","text":"<pre><code>QRegType = PyClass(QReg)\n</code></pre> <p>Kirin type for a quantum register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QubitType","title":"QubitType  <code>module-attribute</code>","text":"<pre><code>QubitType = PyClass(Qubit)\n</code></pre> <p>Kirin type for a qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegEq","title":"CRegEq","text":"<p>               Bases: <code>Statement</code></p> <p>Check if two classical registers are equal.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegEq.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(Int | CRegType | BitType)\n</code></pre> <p>lhs (CReg): The first register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegEq.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre> <p>result (bool): True if the registers are equal, False otherwise.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegEq.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(Int | CRegType | BitType)\n</code></pre> <p>rhs (CReg): The second register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegGet","title":"CRegGet","text":"<p>               Bases: <code>Statement</code></p> <p>Get a bit from a classical register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegGet.idx","title":"idx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idx: SSAValue = argument(Int)\n</code></pre> <p>idx (Int): The index of the bit in the register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegGet.reg","title":"reg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reg: SSAValue = argument(CRegType)\n</code></pre> <p>reg (CReg): The classical register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegGet.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(BitType)\n</code></pre> <p>result (Bit): The bit at position <code>idx</code>.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegNew","title":"CRegNew","text":"<p>               Bases: <code>Statement</code></p> <p>Create a new classical register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegNew.n_bits","title":"n_bits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_bits: SSAValue = argument(Int)\n</code></pre> <p>n_bits (Int): The number of bits in the register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegNew.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(CRegType)\n</code></pre> <p>result (CReg): The new classical register with all bits set to 0.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.Measure","title":"Measure","text":"<p>               Bases: <code>Statement</code></p> <p>Measure a qubit and store the result in a bit.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.Measure.carg","title":"carg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>carg: SSAValue = argument(BitType)\n</code></pre> <p>carg (Bit): The bit to store the result in.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.Measure.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The qubit to measure.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QRegGet","title":"QRegGet","text":"<p>               Bases: <code>Statement</code></p> <p>Get a qubit from a quantum register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QRegGet.idx","title":"idx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idx: SSAValue = argument(Int)\n</code></pre> <p>idx (Int): The index of the qubit in the register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QRegGet.reg","title":"reg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reg: SSAValue = argument(QRegType)\n</code></pre> <p>reg (QReg): The quantum register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QRegGet.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(QubitType)\n</code></pre> <p>result (Qubit): The qubit at position <code>idx</code>.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QRegNew","title":"QRegNew","text":"<p>               Bases: <code>Statement</code></p> <p>Create a new quantum register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QRegNew.n_qubits","title":"n_qubits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_qubits: SSAValue = argument(Int)\n</code></pre> <p>n_qubits: The number of qubits in the register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QRegNew.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(QRegType)\n</code></pre> <p>A new quantum register with n_qubits set to |0&gt;.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.Reset","title":"Reset","text":"<p>               Bases: <code>Statement</code></p> <p>Reset a qubit to the |0&gt; state.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.Reset.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The qubit to reset.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/address/","title":"Address","text":""},{"location":"reference/bloqade/qasm2/dialects/core/emit/","title":"Emit","text":""},{"location":"reference/bloqade/qasm2/dialects/core/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegEq","title":"CRegEq","text":"<p>               Bases: <code>Statement</code></p> <p>Check if two classical registers are equal.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegEq.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(Int | CRegType | BitType)\n</code></pre> <p>lhs (CReg): The first register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegEq.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre> <p>result (bool): True if the registers are equal, False otherwise.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegEq.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(Int | CRegType | BitType)\n</code></pre> <p>rhs (CReg): The second register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegGet","title":"CRegGet","text":"<p>               Bases: <code>Statement</code></p> <p>Get a bit from a classical register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegGet.idx","title":"idx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idx: SSAValue = argument(Int)\n</code></pre> <p>idx (Int): The index of the bit in the register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegGet.reg","title":"reg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reg: SSAValue = argument(CRegType)\n</code></pre> <p>reg (CReg): The classical register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegGet.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(BitType)\n</code></pre> <p>result (Bit): The bit at position <code>idx</code>.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegNew","title":"CRegNew","text":"<p>               Bases: <code>Statement</code></p> <p>Create a new classical register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegNew.n_bits","title":"n_bits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_bits: SSAValue = argument(Int)\n</code></pre> <p>n_bits (Int): The number of bits in the register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegNew.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(CRegType)\n</code></pre> <p>result (CReg): The new classical register with all bits set to 0.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.Measure","title":"Measure","text":"<p>               Bases: <code>Statement</code></p> <p>Measure a qubit and store the result in a bit.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.Measure.carg","title":"carg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>carg: SSAValue = argument(BitType)\n</code></pre> <p>carg (Bit): The bit to store the result in.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.Measure.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The qubit to measure.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegGet","title":"QRegGet","text":"<p>               Bases: <code>Statement</code></p> <p>Get a qubit from a quantum register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegGet.idx","title":"idx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idx: SSAValue = argument(Int)\n</code></pre> <p>idx (Int): The index of the qubit in the register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegGet.reg","title":"reg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reg: SSAValue = argument(QRegType)\n</code></pre> <p>reg (QReg): The quantum register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegGet.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(QubitType)\n</code></pre> <p>result (Qubit): The qubit at position <code>idx</code>.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegNew","title":"QRegNew","text":"<p>               Bases: <code>Statement</code></p> <p>Create a new quantum register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegNew.n_qubits","title":"n_qubits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_qubits: SSAValue = argument(Int)\n</code></pre> <p>n_qubits: The number of qubits in the register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegNew.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(QRegType)\n</code></pre> <p>A new quantum register with n_qubits set to |0&gt;.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.Reset","title":"Reset","text":"<p>               Bases: <code>Statement</code></p> <p>Reset a qubit to the |0&gt; state.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.Reset.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The qubit to reset.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/bloqade/qasm2/dialects/expr/","title":"Index","text":""},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Add","title":"Add","text":"<p>               Bases: <code>Statement</code></p> <p>Add two numbers.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Add.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The left-hand side of the addition.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Add.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the addition.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Add.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The right-hand side of the addition.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.ConstFloat","title":"ConstFloat","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.ConstFloat.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.ConstFloat.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: float = attribute(Float)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.ConstInt","title":"ConstInt","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant integer value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.ConstInt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Int)\n</code></pre> <p>result (Int): The result value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.ConstInt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: int = attribute(Int)\n</code></pre> <p>value (int): The constant integer value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.ConstPI","title":"ConstPI","text":"<p>               Bases: <code>Statement</code></p> <p>The constant value of PI.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.ConstPI.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (ConstPI): The result value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Cos","title":"Cos","text":"<p>               Bases: <code>Statement</code></p> <p>Take the cosine of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Cos.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The cosine of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Cos.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the cosine of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Div","title":"Div","text":"<p>               Bases: <code>Statement</code></p> <p>Divide two numbers.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Div.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The numerator.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Div.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the division.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Div.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The denominator.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Exp","title":"Exp","text":"<p>               Bases: <code>Statement</code></p> <p>Take the exponential of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Exp.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The exponential of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Exp.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the exponential of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.GateFunction","title":"GateFunction","text":"<p>               Bases: <code>Statement</code></p> <p>Special Function for qasm2 gate subroutine.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Log","title":"Log","text":"<p>               Bases: <code>Statement</code></p> <p>Take the natural log of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Log.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The natural log of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Log.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the natural log of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Mul","title":"Mul","text":"<p>               Bases: <code>Statement</code></p> <p>Multiply two numbers.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Mul.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The left-hand side of the multiplication.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Mul.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the multiplication.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Mul.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The right-hand side of the multiplication.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Neg","title":"Neg","text":"<p>               Bases: <code>Statement</code></p> <p>Negate a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Neg.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The negated number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Neg.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to negate.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Pow","title":"Pow","text":"<p>               Bases: <code>Statement</code></p> <p>Take the power of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Pow.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The base.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Pow.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the power operation.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Pow.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The exponent.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sin","title":"Sin","text":"<p>               Bases: <code>Statement</code></p> <p>Take the sine of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sin.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The sine of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sin.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the sine of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sqrt","title":"Sqrt","text":"<p>               Bases: <code>Statement</code></p> <p>Take the square root of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sqrt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The square root of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sqrt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the square root of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sub","title":"Sub","text":"<p>               Bases: <code>Statement</code></p> <p>Subtract two numbers.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sub.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The left-hand side of the subtraction.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sub.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the subtraction.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sub.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The right-hand side of the subtraction.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Tan","title":"Tan","text":"<p>               Bases: <code>Statement</code></p> <p>Take the tangent of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Tan.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The tangent of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Tan.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the tangent of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/emit/","title":"Emit","text":""},{"location":"reference/bloqade/qasm2/dialects/expr/from_python/","title":"From python","text":""},{"location":"reference/bloqade/qasm2/dialects/expr/interp/","title":"Interp","text":""},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Add","title":"Add","text":"<p>               Bases: <code>Statement</code></p> <p>Add two numbers.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Add.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The left-hand side of the addition.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Add.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the addition.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Add.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The right-hand side of the addition.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstFloat","title":"ConstFloat","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstFloat.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstFloat.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: float = attribute(Float)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstInt","title":"ConstInt","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant integer value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstInt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Int)\n</code></pre> <p>result (Int): The result value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstInt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: int = attribute(Int)\n</code></pre> <p>value (int): The constant integer value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstPI","title":"ConstPI","text":"<p>               Bases: <code>Statement</code></p> <p>The constant value of PI.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstPI.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (ConstPI): The result value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Cos","title":"Cos","text":"<p>               Bases: <code>Statement</code></p> <p>Take the cosine of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Cos.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The cosine of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Cos.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the cosine of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Div","title":"Div","text":"<p>               Bases: <code>Statement</code></p> <p>Divide two numbers.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Div.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The numerator.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Div.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the division.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Div.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The denominator.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Exp","title":"Exp","text":"<p>               Bases: <code>Statement</code></p> <p>Take the exponential of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Exp.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The exponential of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Exp.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the exponential of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.GateFunction","title":"GateFunction","text":"<p>               Bases: <code>Statement</code></p> <p>Special Function for qasm2 gate subroutine.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Log","title":"Log","text":"<p>               Bases: <code>Statement</code></p> <p>Take the natural log of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Log.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The natural log of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Log.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the natural log of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Mul","title":"Mul","text":"<p>               Bases: <code>Statement</code></p> <p>Multiply two numbers.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Mul.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The left-hand side of the multiplication.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Mul.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the multiplication.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Mul.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The right-hand side of the multiplication.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Neg","title":"Neg","text":"<p>               Bases: <code>Statement</code></p> <p>Negate a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Neg.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The negated number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Neg.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to negate.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Pow","title":"Pow","text":"<p>               Bases: <code>Statement</code></p> <p>Take the power of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Pow.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The base.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Pow.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the power operation.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Pow.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The exponent.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sin","title":"Sin","text":"<p>               Bases: <code>Statement</code></p> <p>Take the sine of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sin.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The sine of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sin.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the sine of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sqrt","title":"Sqrt","text":"<p>               Bases: <code>Statement</code></p> <p>Take the square root of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sqrt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The square root of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sqrt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the square root of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sub","title":"Sub","text":"<p>               Bases: <code>Statement</code></p> <p>Subtract two numbers.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sub.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The left-hand side of the subtraction.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sub.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the subtraction.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sub.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The right-hand side of the subtraction.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Tan","title":"Tan","text":"<p>               Bases: <code>Statement</code></p> <p>Take the tangent of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Tan.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The tangent of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Tan.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the tangent of.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/","title":"Index","text":""},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.QubitType","title":"QubitType  <code>module-attribute</code>","text":"<pre><code>QubitType = PyClass(Qubit)\n</code></pre> <p>Kirin type for a qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.Barrier","title":"Barrier","text":"<p>               Bases: <code>Statement</code></p> <p>Apply the Barrier statement.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.Barrier.qargs","title":"qargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qargs: tuple[SSAValue, ...] = argument(QubitType)\n</code></pre> <p>qargs: tuple of qubits to apply the barrier to.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CCX","title":"CCX","text":"<p>               Bases: <code>Statement</code></p> <p>Apply the doubly controlled X gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CCX.ctrl1","title":"ctrl1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl1: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl1 (Qubit): The first control qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CCX.ctrl2","title":"ctrl2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl2: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl2 (Qubit): The second control qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CCX.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The target qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CH","title":"CH","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-H gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CRX","title":"CRX","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-RX gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CRX.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The angle to rotate around the X axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CRY","title":"CRY","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-RY gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CRY.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The angle to rotate around the Y axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CRZ","title":"CRZ","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-RZ gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CRZ.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The angle to rotate around the Z axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CSX","title":"CSX","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-Sqrt(X) gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CSwap","title":"CSwap","text":"<p>               Bases: <code>Statement</code></p> <p>Apply the controlled swap gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CSwap.ctrl","title":"ctrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl (Qubit): The control qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CSwap.qarg1","title":"qarg1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg1: SSAValue = argument(QubitType)\n</code></pre> <p>qarg1 (Qubit): The first target qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CSwap.qarg2","title":"qarg2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg2: SSAValue = argument(QubitType)\n</code></pre> <p>qarg2 (Qubit): The second target qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CU","title":"CU","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-U gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CU.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CU.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CU1","title":"CU1","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-U1 gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CU1.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CU3","title":"CU3","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-U3 gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CU3.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CU3.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CX","title":"CX","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Alias for the CNOT or CH gate operations.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CY","title":"CY","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-Y gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CZ","title":"CZ","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-Z gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.H","title":"H","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the Hadamard gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.Id","title":"Id","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the Identity gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.RX","title":"RX","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the RX gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.RX.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle of rotation around x axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.RXX","title":"RXX","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the XX rotation gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.RXX.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle of rotation around the X axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.RY","title":"RY","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the RY gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.RY.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle of rotation around y axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.RZ","title":"RZ","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the RZ gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.RZ.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): the angle of rotation around Z axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.RZZ","title":"RZZ","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the ZZ rotation gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.RZZ.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle of rotation around the Z axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.S","title":"S","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the S gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.SX","title":"SX","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the quantum Sqrt(X) gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.SXdag","title":"SXdag","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the dagger of quantum Sqrt(X) gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.Sdag","title":"Sdag","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the hermitian conj of S gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.SingleQubitGate","title":"SingleQubitGate","text":"<p>               Bases: <code>Statement</code></p> <p>Base class for single qubit gates.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.SingleQubitGate.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The qubit argument.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.Swap","title":"Swap","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Swap gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.T","title":"T","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the T gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.Tdag","title":"Tdag","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the hermitian conj of T gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.TwoQubitCtrlGate","title":"TwoQubitCtrlGate","text":"<p>               Bases: <code>Statement</code></p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.TwoQubitCtrlGate.ctrl","title":"ctrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl (Qubit): The control qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.TwoQubitCtrlGate.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The target qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.U1","title":"U1","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the U1 gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.U1.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.U2","title":"U2","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the U2 gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.U2.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.U2.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.UGate","title":"UGate","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply A general single qubit unitary gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.UGate.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.UGate.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.UGate.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The theta parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.X","title":"X","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the X gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.Y","title":"Y","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the Y gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.Z","title":"Z","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the Z gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/emit/","title":"Emit","text":""},{"location":"reference/bloqade/qasm2/dialects/uop/schedule/","title":"Schedule","text":""},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Barrier","title":"Barrier","text":"<p>               Bases: <code>Statement</code></p> <p>Apply the Barrier statement.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Barrier.qargs","title":"qargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qargs: tuple[SSAValue, ...] = argument(QubitType)\n</code></pre> <p>qargs: tuple of qubits to apply the barrier to.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CCX","title":"CCX","text":"<p>               Bases: <code>Statement</code></p> <p>Apply the doubly controlled X gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CCX.ctrl1","title":"ctrl1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl1: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl1 (Qubit): The first control qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CCX.ctrl2","title":"ctrl2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl2: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl2 (Qubit): The second control qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CCX.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The target qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CH","title":"CH","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-H gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CRX","title":"CRX","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-RX gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CRX.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The angle to rotate around the X axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CRY","title":"CRY","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-RY gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CRY.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The angle to rotate around the Y axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CRZ","title":"CRZ","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-RZ gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CRZ.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The angle to rotate around the Z axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CSX","title":"CSX","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-Sqrt(X) gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CSwap","title":"CSwap","text":"<p>               Bases: <code>Statement</code></p> <p>Apply the controlled swap gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CSwap.ctrl","title":"ctrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl (Qubit): The control qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CSwap.qarg1","title":"qarg1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg1: SSAValue = argument(QubitType)\n</code></pre> <p>qarg1 (Qubit): The first target qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CSwap.qarg2","title":"qarg2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg2: SSAValue = argument(QubitType)\n</code></pre> <p>qarg2 (Qubit): The second target qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU","title":"CU","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-U gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU1","title":"CU1","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-U1 gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU1.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU3","title":"CU3","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-U3 gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU3.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU3.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CX","title":"CX","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Alias for the CNOT or CH gate operations.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CY","title":"CY","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-Y gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CZ","title":"CZ","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-Z gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.H","title":"H","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the Hadamard gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Id","title":"Id","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the Identity gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RX","title":"RX","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the RX gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RX.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle of rotation around x axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RXX","title":"RXX","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the XX rotation gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RXX.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle of rotation around the X axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RY","title":"RY","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the RY gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RY.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle of rotation around y axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RZ","title":"RZ","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the RZ gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RZ.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): the angle of rotation around Z axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RZZ","title":"RZZ","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the ZZ rotation gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RZZ.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle of rotation around the Z axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.S","title":"S","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the S gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.SX","title":"SX","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the quantum Sqrt(X) gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.SXdag","title":"SXdag","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the dagger of quantum Sqrt(X) gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Sdag","title":"Sdag","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the hermitian conj of S gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.SingleQubitGate","title":"SingleQubitGate","text":"<p>               Bases: <code>Statement</code></p> <p>Base class for single qubit gates.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.SingleQubitGate.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The qubit argument.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Swap","title":"Swap","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Swap gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.T","title":"T","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the T gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Tdag","title":"Tdag","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the hermitian conj of T gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate","title":"TwoQubitCtrlGate","text":"<p>               Bases: <code>Statement</code></p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate.ctrl","title":"ctrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl (Qubit): The control qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The target qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.U1","title":"U1","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the U1 gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.U1.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.U2","title":"U2","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the U2 gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.U2.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.U2.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.UGate","title":"UGate","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply A general single qubit unitary gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.UGate.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.UGate.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.UGate.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The theta parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.X","title":"X","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the X gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Y","title":"Y","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the Y gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Z","title":"Z","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the Z gate.</p>"},{"location":"reference/bloqade/qasm2/emit/","title":"Index","text":""},{"location":"reference/bloqade/qasm2/emit/base/","title":"Base","text":""},{"location":"reference/bloqade/qasm2/emit/gate/","title":"Gate","text":""},{"location":"reference/bloqade/qasm2/emit/main/","title":"Main","text":""},{"location":"reference/bloqade/qasm2/emit/target/","title":"Target","text":""},{"location":"reference/bloqade/qasm2/emit/target/#bloqade.qasm2.emit.target.QASM2","title":"QASM2","text":"<pre><code>QASM2(\n    qelib1: bool = True,\n    allow_parallel: bool = False,\n    allow_global: bool = False,\n    custom_gate: bool = True,\n)\n</code></pre> <p>QASM2 target for Bloqade kernels.</p> <p>QASM2 target that accepts a Bloqade kernel and produces an AST that you can then obtain a string for printing or saving as a file.</p> <p>Parameters:</p> Name Type Description Default <code>allow_parallel</code> <code>bool</code> <p>Allow parallel gate in the resulting QASM2 AST. Defaults to <code>False</code>. In the case its False, and the input kernel uses parallel gates, they will get rewrite into uop gates.</p> <code>False</code> <code>allow_global</code> <code>bool</code> <p>Allow global gate in the resulting QASM2 AST. Defaults to <code>False</code>. In the case its False, and the input kernel uses global gates, they will get rewrite into parallel gates. If both <code>allow_parallel</code> and <code>allow_global</code> are False, the input kernel will be rewritten to use uop gates.</p> <code>False</code> <code>qelib1</code> <code>bool</code> <p>Include the <code>include \"qelib1.inc\"</code> line in the resulting QASM2 AST that's submitted to qBraid. Defaults to <code>True</code>.</p> <code>True</code> <code>custom_gate</code> <code>bool</code> <p>Include the custom gate definitions in the resulting QASM2 AST. Defaults to <code>True</code>. If <code>False</code>, all the qasm2.gate will be inlined.</p> <code>True</code> Source code in <code>src/bloqade/qasm2/emit/target.py</code> <pre><code>def __init__(\n    self,\n    qelib1: bool = True,\n    allow_parallel: bool = False,\n    allow_global: bool = False,\n    custom_gate: bool = True,\n) -&gt; None:\n    \"\"\"Initialize the QASM2 target.\n\n    Args:\n        allow_parallel (bool):\n            Allow parallel gate in the resulting QASM2 AST. Defaults to `False`.\n            In the case its False, and the input kernel uses parallel gates, they will get rewrite into uop gates.\n\n        allow_global (bool):\n            Allow global gate in the resulting QASM2 AST. Defaults to `False`.\n            In the case its False, and the input kernel uses global gates, they will get rewrite into parallel gates.\n            If both `allow_parallel` and `allow_global` are False, the input kernel will be rewritten to use uop gates.\n\n        qelib1 (bool):\n            Include the `include \"qelib1.inc\"` line in the resulting QASM2 AST that's\n            submitted to qBraid. Defaults to `True`.\n        custom_gate (bool):\n            Include the custom gate definitions in the resulting QASM2 AST. Defaults to `True`. If `False`, all the qasm2.gate will be inlined.\n\n\n\n    \"\"\"\n    from bloqade import qasm2\n\n    self.main_target = qasm2.main\n    self.gate_target = qasm2.gate\n\n    self.qelib1 = qelib1\n    self.custom_gate = custom_gate\n    self.allow_parallel = allow_parallel\n    self.allow_global = allow_global\n\n    if allow_parallel:\n        self.main_target = self.main_target.add(qasm2.dialects.parallel)\n        self.gate_target = self.gate_target.add(qasm2.dialects.parallel)\n\n    if allow_global:\n        self.main_target = self.main_target.add(qasm2.dialects.glob)\n        self.gate_target = self.gate_target.add(qasm2.dialects.glob)\n\n    if allow_global or allow_parallel:\n        self.main_target = self.main_target.add(ilist)\n        self.gate_target = self.gate_target.add(ilist)\n</code></pre>"},{"location":"reference/bloqade/qasm2/emit/target/#bloqade.qasm2.emit.target.QASM2.emit","title":"emit","text":"<pre><code>emit(entry: Method) -&gt; ast.MainProgram\n</code></pre> <p>Emit a QASM2 AST from the Bloqade kernel.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>Method</code> <p>The Bloqade kernel to convert to the QASM2 AST</p> required <p>Returns:</p> Type Description <code>MainProgram</code> <p>ast.MainProgram: A QASM2 AST object</p> Source code in <code>src/bloqade/qasm2/emit/target.py</code> <pre><code>def emit(self, entry: ir.Method) -&gt; ast.MainProgram:\n    \"\"\"Emit a QASM2 AST from the Bloqade kernel.\n\n    Args:\n        entry (ir.Method):\n            The Bloqade kernel to convert to the QASM2 AST\n\n    Returns:\n        ast.MainProgram:\n            A QASM2 AST object\n\n    \"\"\"\n    assert len(entry.args) == 0, \"entry method should not have arguments\"\n\n    # make a cloned instance of kernel\n    entry = entry.similar()\n    QASM2Fold(entry.dialects, inline_gate_subroutine=not self.custom_gate).fixpoint(\n        entry\n    )\n\n    if not self.allow_global:\n        # rewrite global to parallel\n        GlobalToParallel(dialects=entry.dialects)(entry)\n\n    if not self.allow_parallel:\n        # rewrite parallel to uop\n        ParallelToUOp(dialects=entry.dialects)(entry)\n\n    Py2QASM(entry.dialects)(entry)\n    target_main = EmitQASM2Main(self.main_target)\n    target_main.run(\n        entry, tuple(ast.Name(name) for name in entry.arg_names[1:])\n    ).expect()\n\n    main_program = target_main.output\n    assert main_program is not None, f\"failed to emit {entry.sym_name}\"\n\n    extra = []\n    if self.qelib1:\n        extra.append(ast.Include(\"qelib1.inc\"))\n\n    if self.custom_gate:\n        cg = CallGraph(entry)\n        target_gate = EmitQASM2Gate(self.gate_target)\n\n        for _, fn in cg.defs.items():\n            if fn is entry:\n                continue\n\n            fn = fn.similar()\n            QASM2Fold(fn.dialects).fixpoint(fn)\n\n            if not self.allow_global:\n                # rewrite global to parallel\n                GlobalToParallel(dialects=fn.dialects)(fn)\n\n            if not self.allow_parallel:\n                # rewrite parallel to uop\n                ParallelToUOp(dialects=fn.dialects)(fn)\n\n            Py2QASM(fn.dialects)(fn)\n\n            target_gate.run(\n                fn, tuple(ast.Name(name) for name in fn.arg_names[1:])\n            ).expect()\n            assert target_gate.output is not None, f\"failed to emit {fn.sym_name}\"\n            extra.append(target_gate.output)\n\n    main_program.statements = extra + main_program.statements\n    return main_program\n</code></pre>"},{"location":"reference/bloqade/qasm2/emit/target/#bloqade.qasm2.emit.target.QASM2.emit_str","title":"emit_str","text":"<pre><code>emit_str(entry: Method) -&gt; str\n</code></pre> <p>Emit a QASM2 AST from the Bloqade kernel.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>Method</code> <p>The Bloqade kernel to convert to the QASM2 AST</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string with the QASM2 representation of the kernel</p> Source code in <code>src/bloqade/qasm2/emit/target.py</code> <pre><code>def emit_str(self, entry: ir.Method) -&gt; str:\n    \"\"\"Emit a QASM2 AST from the Bloqade kernel.\n\n    Args:\n        entry (ir.Method):\n            The Bloqade kernel to convert to the QASM2 AST\n\n    Returns:\n        str:\n            A string with the QASM2 representation of the kernel\n\n    \"\"\"\n    console = Console(\n        file=io.StringIO(),\n        force_terminal=False,\n        force_interactive=False,\n        force_jupyter=False,\n        record=True,\n    )\n    pprint(self.emit(entry), console=console)\n    return console.export_text()\n</code></pre>"},{"location":"reference/bloqade/qasm2/parse/","title":"Index","text":""},{"location":"reference/bloqade/qasm2/parse/ast/","title":"Ast","text":""},{"location":"reference/bloqade/qasm2/parse/build/","title":"Build","text":""},{"location":"reference/bloqade/qasm2/parse/lowering/","title":"Lowering","text":""},{"location":"reference/bloqade/qasm2/parse/lowering/#bloqade.qasm2.parse.lowering.QASM2","title":"QASM2  <code>dataclass</code>","text":"<pre><code>QASM2(\n    *,\n    max_lines: int = 3,\n    hint_indent: int = 2,\n    hint_show_lineno: bool = True,\n    stacktrace: bool = True\n)\n</code></pre> <p>               Bases: <code>LoweringABC[Node]</code></p>"},{"location":"reference/bloqade/qasm2/parse/lowering/#bloqade.qasm2.parse.lowering.QASM2.branch_next_if_not_terminated","title":"branch_next_if_not_terminated","text":"<pre><code>branch_next_if_not_terminated(frame: Frame)\n</code></pre> <p>Branch to the next block if the current block is not terminated.</p> <p>This must be used after exhausting the current frame and before popping the frame.</p> Source code in <code>src/bloqade/qasm2/parse/lowering.py</code> <pre><code>def branch_next_if_not_terminated(self, frame: lowering.Frame):\n    \"\"\"Branch to the next block if the current block is not terminated.\n\n    This must be used after exhausting the current frame and before popping the frame.\n    \"\"\"\n    if not frame.curr_block.last_stmt or not frame.curr_block.last_stmt.has_trait(\n        ir.IsTerminator\n    ):\n        frame.curr_block.stmts.append(\n            cf.Branch(arguments=(), successor=frame.next_block)\n        )\n</code></pre>"},{"location":"reference/bloqade/qasm2/parse/parser/","title":"Parser","text":""},{"location":"reference/bloqade/qasm2/parse/print/","title":"Print","text":""},{"location":"reference/bloqade/qasm2/parse/visitor/","title":"Visitor","text":""},{"location":"reference/bloqade/qasm2/passes/","title":"Index","text":""},{"location":"reference/bloqade/qasm2/passes/fold/","title":"Fold","text":""},{"location":"reference/bloqade/qasm2/passes/fold/#bloqade.qasm2.passes.fold.QASM2Fold","title":"QASM2Fold  <code>dataclass</code>","text":"<pre><code>QASM2Fold(inline_gate_subroutine: bool = True)\n</code></pre> <p>               Bases: <code>Pass</code></p> <p>Fold pass for qasm2.extended</p>"},{"location":"reference/bloqade/qasm2/passes/glob/","title":"Glob","text":"<p>Passes that deal with global gates. As of now, only one rewrite pass exists which converts global gates to single qubit gates.</p>"},{"location":"reference/bloqade/qasm2/passes/glob/#bloqade.qasm2.passes.glob.GlobalToParallel","title":"GlobalToParallel","text":"<p>               Bases: <code>Pass</code></p> <p>Pass to convert Global gates into parallel gates.</p> <p>This pass rewrites the global unitary gate from the <code>qasm2.glob</code> dialect into multiple parallel gates in the <code>qasm2.parallel</code> dialect.</p>"},{"location":"reference/bloqade/qasm2/passes/glob/#bloqade.qasm2.passes.glob.GlobalToParallel--usage-examples","title":"Usage Examples","text":"<pre><code># Define kernel\n@qasm2.extended\ndef main():\n    q1 = qasm2.qreg(1)\n    q2 = qasm2.qreg(2)\n\n    theta = 1.3\n    phi = 1.1\n    lam = 1.2\n\n    qasm2.glob.u(theta=theta, phi=phi, lam=lam, registers=[q1, q2])\n\nGlobalToParallel(dialects=main.dialects)(main)\n\n# Run rewrite\nGlobalToParallel(main.dialects)(main)\n</code></pre> <p>The <code>qasm2.glob.u</code> statement has been rewritten to individual gates:</p> <pre><code>qasm2.parallel.u(theta=theta, phi=phi, lam=lam, qargs=[q1[0], q2[0], q2[1]])\n</code></pre>"},{"location":"reference/bloqade/qasm2/passes/glob/#bloqade.qasm2.passes.glob.GlobalToUOP","title":"GlobalToUOP","text":"<p>               Bases: <code>Pass</code></p> <p>Pass to convert Global gates into single gates.</p> <p>This pass rewrites the global unitary gate from the <code>qasm2.glob</code> dialect into multiple single gates in the <code>qasm2.uop</code> dialect, bringing the program closer to conforming to standard QASM2 syntax.</p>"},{"location":"reference/bloqade/qasm2/passes/glob/#bloqade.qasm2.passes.glob.GlobalToUOP--usage-examples","title":"Usage Examples","text":"<pre><code># Define kernel\n@qasm2.extended\ndef main():\n    q1 = qasm2.qreg(1)\n    q2 = qasm2.qreg(2)\n\n    theta = 1.3\n    phi = 1.1\n    lam = 1.2\n\n    qasm2.glob.u(theta=theta, phi=phi, lam=lam, registers=[q1, q2])\n\nGlobalToUOP(dialects=main.dialects)(main)\n\n# Run rewrite\nGlobalToUOP(main.dialects)(main)\n</code></pre> <p>The <code>qasm2.glob.u</code> statement has been rewritten to individual gates:</p> <pre><code>qasm2.uop.u(q1[0], theta, phi, lam)\nqasm2.uop.u(q2[0], theta, phi, lam)\nqasm2.uop.u(q2[1], theta, phi, lam)\n</code></pre>"},{"location":"reference/bloqade/qasm2/passes/noise/","title":"Noise","text":""},{"location":"reference/bloqade/qasm2/passes/noise/#bloqade.qasm2.passes.noise.NoisePass","title":"NoisePass  <code>dataclass</code>","text":"<pre><code>NoisePass(\n    noise_model: MoveNoiseModelABC = native.TwoRowZoneModel(),\n    gate_noise_params: GateNoiseParams = native.GateNoiseParams(),\n)\n</code></pre> <p>               Bases: <code>Pass</code></p> <p>Apply a noise model to a quantum circuit.</p> <p>NOTE: This pass is not guaranteed to be supported long-term in bloqade. We will be moving towards a more general approach to noise modeling in the future.</p>"},{"location":"reference/bloqade/qasm2/passes/parallel/","title":"Parallel","text":"<p>Passes for converting parallel gates into multiple single gates as well as converting multiple single gates to parallel gates.</p>"},{"location":"reference/bloqade/qasm2/passes/parallel/#bloqade.qasm2.passes.parallel.ParallelToUOp","title":"ParallelToUOp  <code>dataclass</code>","text":"<pre><code>ParallelToUOp()\n</code></pre> <p>               Bases: <code>Pass</code></p> <p>Pass to convert parallel gates into single gates.</p> <p>This pass rewrites any parallel gates from the <code>qasm2.parallel</code> dialect into multiple single gates in the <code>qasm2.uop</code> dialect, bringing the program closer to conforming to standard QASM2 syntax.</p>"},{"location":"reference/bloqade/qasm2/passes/parallel/#bloqade.qasm2.passes.parallel.ParallelToUOp--usage-examples","title":"Usage Examples","text":"<pre><code># Define kernel\n@qasm2.extended\ndef main():\n    q = qasm2.qreg(4)\n\n    qasm2.parallel.cz(ctrls=[q[0], q[2]], qargs=[q[1], q[3]])\n\n# Run rewrite\nParallelToUOp(main.dialects)(main)\n</code></pre> <p>The <code>qasm2.parallel.cz</code> statement has been rewritten to individual gates:</p> <pre><code>qasm2.uop.cz(ctrl=q[0], qarg=q[1])\nqasm2.uop.cz(ctrl=q[2], qarg=q[3])\n</code></pre>"},{"location":"reference/bloqade/qasm2/passes/parallel/#bloqade.qasm2.passes.parallel.UOpToParallel","title":"UOpToParallel  <code>dataclass</code>","text":"<pre><code>UOpToParallel(\n    merge_policy_type: Type[\n        MergePolicyABC\n    ] = SimpleOptimalMergePolicy,\n)\n</code></pre> <p>               Bases: <code>Pass</code></p> <p>Pass to convert single gates into parallel gates.</p> <p>This pass looks for single gates from the <code>qasm2.uop</code> dialect that can be combined into parallel gates from the <code>qasm2.parallel</code> dialect and performs a rewrite to do so.</p>"},{"location":"reference/bloqade/qasm2/passes/parallel/#bloqade.qasm2.passes.parallel.UOpToParallel--usage-examples","title":"Usage Examples","text":"<pre><code># Define kernel\n@qasm2.main\ndef test():\n    q = qasm2.qreg(4)\n\n    theta = 0.1\n    phi = 0.2\n    lam = 0.3\n\n    qasm2.u(q[1], theta, phi, lam)\n    qasm2.u(q[3], theta, phi, lam)\n    qasm2.cx(q[1], q[3])\n    qasm2.u(q[2], theta, phi, lam)\n    qasm2.u(q[0], theta, phi, lam)\n    qasm2.cx(q[0], q[2])\n\n# Run rewrite\nUOpToParallel(main.dialects)(main)\n</code></pre> <p>The individual <code>qasm2.u</code> statements have now been combined into a single <code>qasm2.parallel.u</code> statement.</p> <pre><code>qasm2.parallel.u(qargs = [q[0], q[1], q[2], q[3]], theta, phi, lam)\nqasm2.uop.CX(q[1], q[3])\nqasm2.uop.CX(q[0], q[2])\n</code></pre>"},{"location":"reference/bloqade/qasm2/passes/py2qasm/","title":"Py2qasm","text":"<p>Rewrite py dialects into qasm dialects.</p>"},{"location":"reference/bloqade/qasm2/passes/qasm2py/","title":"Qasm2py","text":"<p>Rewrite qasm dialects into py dialects.</p>"},{"location":"reference/bloqade/qasm2/rewrite/","title":"Index","text":""},{"location":"reference/bloqade/qasm2/rewrite/desugar/","title":"Desugar","text":""},{"location":"reference/bloqade/qasm2/rewrite/glob/","title":"Glob","text":""},{"location":"reference/bloqade/qasm2/rewrite/heuristic_noise/","title":"Heuristic noise","text":""},{"location":"reference/bloqade/qasm2/rewrite/heuristic_noise/#bloqade.qasm2.rewrite.heuristic_noise.NoiseRewriteRule","title":"NoiseRewriteRule  <code>dataclass</code>","text":"<pre><code>NoiseRewriteRule(\n    address_analysis: Dict[SSAValue, Address],\n    gate_noise_params: GateNoiseParams = native.GateNoiseParams(),\n    noise_model: MoveNoiseModelABC = native.TwoRowZoneModel(),\n)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>NOTE: This pass is not guaranteed to be supported long-term in bloqade. We will be moving towards a more general approach to noise modeling in the future.</p>"},{"location":"reference/bloqade/qasm2/rewrite/native_gates/","title":"Native gates","text":""},{"location":"reference/bloqade/qasm2/rewrite/parallel_to_uop/","title":"Parallel to uop","text":""},{"location":"reference/bloqade/qasm2/rewrite/register/","title":"Register","text":""},{"location":"reference/bloqade/qasm2/rewrite/register/#bloqade.qasm2.rewrite.register.RaiseRegisterRule","title":"RaiseRegisterRule","text":"<p>               Bases: <code>RewriteRule</code></p> <p>This rule puts all registers at the top of the block.</p> <p>This is required for the UOpToParallel rules to work correctly to handle cases where a register is defined in between two statements that can be parallelized.</p>"},{"location":"reference/bloqade/qasm2/rewrite/uop_to_parallel/","title":"Uop to parallel","text":""},{"location":"reference/bloqade/qasm2/rewrite/uop_to_parallel/#bloqade.qasm2.rewrite.uop_to_parallel.GreedyMixin","title":"GreedyMixin","text":"<p>               Bases: <code>MergePolicyABC</code></p> <p>Merge policy that greedily merges gates together.</p> <p>The <code>merge_gates</code> method will merge policy will try greedily merge gates together. This policy has a worst case complexity of O(n) where n is the number of gates in the input iterable.</p>"},{"location":"reference/bloqade/qasm2/rewrite/uop_to_parallel/#bloqade.qasm2.rewrite.uop_to_parallel.OptimalMixIn","title":"OptimalMixIn","text":"<p>               Bases: <code>MergePolicyABC</code></p> <p>Merge policy that merges gates together optimally.</p> <p>The <code>merge_gates</code> method will merge policy will try to merge every gate into every group of gates, terminating when it finds a group that can be merged with the current gate. This policy has a worst case complexity of O(n^2) where n is the number of gates in the input iterable.</p>"},{"location":"reference/bloqade/qasm2/rewrite/uop_to_parallel/#bloqade.qasm2.rewrite.uop_to_parallel.SimpleMergePolicy","title":"SimpleMergePolicy  <code>dataclass</code>","text":"<pre><code>SimpleMergePolicy(\n    address_analysis: Dict[SSAValue, Address],\n    merge_groups: List[List[Statement]],\n    group_numbers: Dict[Statement, int],\n    group_has_merged: Dict[int, bool] = dict(),\n)\n</code></pre> <p>               Bases: <code>MergePolicyABC</code></p> <p>General merge policy for merging gates based on their type and arguments.</p> <p>Base class to implement a merge policy for CZ, U and RZ gates, To completed the policy implement the <code>merge_gates</code> class method. This will take an iterable of statements and return a list of groups of statements that can be merged together. There are two mix-in classes that can be used to implement the <code>merge_gates</code> method. The <code>GreedyMixin</code> will merge gates together greedily, while the <code>OptimalMixIn</code> will merge gates together optimally.</p>"},{"location":"reference/bloqade/qasm2/rewrite/uop_to_parallel/#bloqade.qasm2.rewrite.uop_to_parallel.SimpleMergePolicy.address_analysis","title":"address_analysis  <code>instance-attribute</code>","text":"<pre><code>address_analysis: Dict[SSAValue, Address]\n</code></pre> <p>Mapping from SSA values to their address analysis results. Needed for rewrites</p>"},{"location":"reference/bloqade/qasm2/rewrite/uop_to_parallel/#bloqade.qasm2.rewrite.uop_to_parallel.SimpleMergePolicy.group_has_merged","title":"group_has_merged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group_has_merged: Dict[int, bool] = field(\n    default_factory=dict\n)\n</code></pre> <p>Mapping from group number to whether the group has been merged</p>"},{"location":"reference/bloqade/qasm2/rewrite/uop_to_parallel/#bloqade.qasm2.rewrite.uop_to_parallel.SimpleMergePolicy.group_numbers","title":"group_numbers  <code>instance-attribute</code>","text":"<pre><code>group_numbers: Dict[Statement, int]\n</code></pre> <p>Mapping from statements to their group number</p>"},{"location":"reference/bloqade/qasm2/rewrite/uop_to_parallel/#bloqade.qasm2.rewrite.uop_to_parallel.SimpleMergePolicy.merge_groups","title":"merge_groups  <code>instance-attribute</code>","text":"<pre><code>merge_groups: List[List[Statement]]\n</code></pre> <p>List of groups of statements that can be merged together</p>"},{"location":"reference/bloqade/qbraid/","title":"Index","text":""},{"location":"reference/bloqade/qbraid/lowering/","title":"Lowering","text":""},{"location":"reference/bloqade/qbraid/lowering/#bloqade.qbraid.lowering.Lowering","title":"Lowering  <code>dataclass</code>","text":"<pre><code>Lowering()\n</code></pre>"},{"location":"reference/bloqade/qbraid/lowering/#bloqade.qbraid.lowering.Lowering.lower","title":"lower","text":"<pre><code>lower(\n    sym_name: str,\n    noise_model: NoiseModel,\n    return_qreg: bool = False,\n) -&gt; ir.Method\n</code></pre> <p>Lower the noise model to a method.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the method to generate.</p> required <code>return_qreg</code> <code>bool</code> <p>Use the quantum register as the return value.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Method</code> <code>Method</code> <p>The generated kirin method.</p> Source code in <code>src/bloqade/qbraid/lowering.py</code> <pre><code>def lower(\n    self,\n    sym_name: str,\n    noise_model: schema.NoiseModel,\n    return_qreg: bool = False,\n) -&gt; ir.Method:\n    \"\"\"Lower the noise model to a method.\n\n    Args:\n        name (str): The name of the method to generate.\n        return_qreg (bool): Use the quantum register as the return value.\n\n    Returns:\n        Method: The generated kirin method.\n\n    \"\"\"\n    self.process_noise_model(noise_model, return_qreg)\n    block = ir.Block(stmts=self.block_list)\n    ret_type = qasm2.types.QRegType if return_qreg else qasm2.types.CRegType\n    block.args.append_from(types.MethodType[[], ret_type], name=f\"{sym_name}_self\")\n    region = ir.Region(block)\n    func_stmt = func.Function(\n        sym_name=sym_name,\n        signature=func.Signature(inputs=(), output=qasm2.types.QRegType),\n        body=region,\n    )\n\n    mt = ir.Method(\n        mod=None,\n        py_func=None,\n        sym_name=sym_name,\n        dialects=qbraid_noise,\n        code=func_stmt,\n        arg_names=[],\n    )\n    qbraid_noise.run_pass(mt)  # type: ignore\n    return mt\n</code></pre>"},{"location":"reference/bloqade/qbraid/schema/","title":"Schema","text":""},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.CZ","title":"CZ","text":"<p>               Bases: <code>Operation</code></p> <p>A CZ gate operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"CZ\"]). participants (Tuple[Union[Tuple[int], Tuple[int, int]], ...]): The qubit indices that are participating in the CZ gate.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.CZError","title":"CZError","text":"<p>               Bases: <code>ErrorOperation[ErrorModelType]</code></p> <p>CZError operation.</p> Fields <p>survival_prob (Tuple[float, ...]): The survival probabilities for each qubit. error_type (str): The type of error (Literal[\"CZError\"]). storage_error (ErrorModelType): The error model for storage. entangled_error (ErrorModelType): The error model for entangled qubits. single_error (ErrorModelType): The error model for single qubits.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.ErrorModel","title":"ErrorModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for error models.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.ErrorOperation","title":"ErrorOperation","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[ErrorModelType]</code></p> <p>Base class for error operations.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.GateEvent","title":"GateEvent","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[ErrorModelType]</code></p> <p>A gate event.</p> Fields <p>error (Union[SingleQubitError[ErrorModelType], CZError[ErrorModelType]]): The error model for the gate event. operation (OperationType): The operation for the gate event.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.GlobalRz","title":"GlobalRz","text":"<p>               Bases: <code>Operation</code></p> <p>GlobalRz operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"GlobalRz\"]). phi (float): The angle of rotation.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.GlobalW","title":"GlobalW","text":"<p>               Bases: <code>Operation</code></p> <p>GlobalW operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"GlobalW\"]). theta (float): The angle of rotation. phi (float): The angle of rotation.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.LocalRz","title":"LocalRz","text":"<p>               Bases: <code>Operation</code></p> <p>LocalRz operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"LocalRz\"]). participants (Tuple[int, ...]): The qubit indices that are participating in the local Rz gate. phi (float): The angle of rotation.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.LocalW","title":"LocalW","text":"<p>               Bases: <code>Operation</code></p> <p>LocalW operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"LocalW\"]). participants (Tuple[int, ...]): The qubit indices that are participating in the local W gate. theta (float): The angle of rotation. phi (float): The angle of rotation.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.Measurement","title":"Measurement","text":"<p>               Bases: <code>Operation</code></p> <p>Measurement operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"Measurement\"]). measure_tag (str): The tag to use for the measurement. participants (Tuple[int, ...]): The qubit indices that are participating in the measurement.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.NoiseModel","title":"NoiseModel","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[ErrorModelType]</code></p> <p>Noise model for a circuit.</p> Fields <p>all_qubits (Tuple[int, ...]): The qubit indices for the noise model. gate_events (List[GateEvent[ErrorModelType]]): The gate events for the noise model.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.NoiseModel.num_qubits","title":"num_qubits  <code>property</code>","text":"<pre><code>num_qubits: int\n</code></pre> <p>Return the number of qubits in the noise model.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.NoiseModel.decompiled_circuit","title":"decompiled_circuit","text":"<pre><code>decompiled_circuit() -&gt; str\n</code></pre> <p>Clean the circuit of noise.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The decompiled circuit from hardware execution.</p> Source code in <code>src/bloqade/qbraid/schema.py</code> <pre><code>def decompiled_circuit(self) -&gt; str:\n    \"\"\"Clean the circuit of noise.\n\n    Returns:\n        str: The decompiled circuit from hardware execution.\n\n    \"\"\"\n    from bloqade.noise import native\n    from bloqade.qasm2.emit import QASM2\n    from bloqade.qasm2.passes import glob, parallel\n\n    mt = self.lower_noise_model(\"method\")\n\n    native.RemoveNoisePass(mt.dialects)(mt)\n    parallel.ParallelToUOp(mt.dialects)(mt)\n    glob.GlobalToUOP(mt.dialects)(mt)\n    return QASM2(qelib1=True).emit_str(mt)\n</code></pre>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.NoiseModel.lower_noise_model","title":"lower_noise_model","text":"<pre><code>lower_noise_model(sym_name: str, return_qreg: bool = False)\n</code></pre> <p>Lower the noise model to a method.</p> <p>Parameters:</p> Name Type Description Default <code>sym_name</code> <code>str</code> <p>The name of the method to generate.</p> required <code>return_qreg</code> <code>bool</code> <p>Whether to return the quantum register after the method has completed execution. Useful for obtaining the full state vector.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Method</code> <p>The generated kirin method.</p> Source code in <code>src/bloqade/qbraid/schema.py</code> <pre><code>def lower_noise_model(self, sym_name: str, return_qreg: bool = False):\n    \"\"\"Lower the noise model to a method.\n\n    Args:\n        sym_name (str): The name of the method to generate.\n        return_qreg (bool): Whether to return the quantum register after the method\n            has completed execution. Useful for obtaining the full state vector.\n\n    Returns:\n        Method: The generated kirin method.\n\n    \"\"\"\n    from bloqade.qbraid.lowering import Lowering\n\n    return Lowering().lower(sym_name, self, return_qreg)\n</code></pre>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.Operation","title":"Operation","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for operations.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.PauliErrorModel","title":"PauliErrorModel","text":"<p>               Bases: <code>ErrorModel</code></p> <p>Pauli error model.</p> Fields <p>error_model_type (str): The type of error model (Literal[\"PauliNoise\"]). errors (Tuple[Tuple[int, Tuple[float, float, float]], ...]): The qubit indices and the error rates for each qubit.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.SingleQubitError","title":"SingleQubitError","text":"<p>               Bases: <code>ErrorOperation[ErrorModelType]</code></p> <p>SingleQubitError operation.</p> Fields <p>survival_prob (Tuple[float, ...]): The survival probabilities for each qubit. error_type (str): The type of error (Literal[\"SingleQubitError\"]). operator_error (ErrorModelType): The error model for the single qubit.</p>"},{"location":"reference/bloqade/qbraid/simulation_result/","title":"Simulation result","text":""},{"location":"reference/bloqade/qbraid/simulation_result/#bloqade.qbraid.simulation_result.QuEraSimulationResult","title":"QuEraSimulationResult  <code>dataclass</code>","text":"<pre><code>QuEraSimulationResult(\n    flair_visual_version: str,\n    counts: dict[str, int],\n    logs: DataFrame,\n    atom_animation_state: AnimateQPUState,\n    noise_model: NoiseModel,\n)\n</code></pre> <p>Results of the QuEra hardware model simulation.</p> Fields <p>flair_visual_version (str): The version of the Flair Visual package used to generate the simulation result. counts (dict[str, int]): The measurement bitstrings of the simulation. logs (DataFrame): Grainular logs events of what happened to each atom during the simulation. atom_animation_state (vis_qpustate.AnimateQPUState): Object used to play back atom trajectories and events during the simulation. noise_model (NoiseModel): The noise model used in the simulation.</p>"},{"location":"reference/bloqade/qbraid/simulation_result/#bloqade.qbraid.simulation_result.QuEraSimulationResult.animate","title":"animate","text":"<pre><code>animate(\n    dilation_rate: float = 0.05,\n    fps: int = 30,\n    gate_display_dilation: float = 1.0,\n    save_mpeg: bool = False,\n    filename: str = \"vqpu_animation\",\n    start_block: int = 0,\n    n_blocks: Optional[int] = None,\n)\n</code></pre> <p>animate the qpu state</p> <p>Parameters:</p> Name Type Description Default <code>dilation_rate</code> <code>float</code> <p>Conversion factor from the qpu time to animation time units. when dilation_rate=1.0, 1 (us) of qpu exec time corresponds to 1 second of animation time.</p> <code>0.05</code> <code>fps</code> <code>int</code> <p>frame per second. Defaults to 30.</p> <code>30</code> <code>gate_display_dilation</code> <code>float</code> <p>relative dilation rate of a gate event. Defaults to 1. When setting higher value, the gate event will be displayed longer.</p> <code>1.0</code> <code>save_mpeg</code> <code>bool</code> <p>Save as mpeg. Defaults to False.</p> <code>False</code> <code>filename</code> <code>str</code> <p>The file name of saved mpeg file. Defaults to \"vqpu_animation\". When <code>save_mpeg</code> is False, this argument is ignored.</p> <code>'vqpu_animation'</code> <code>start_block</code> <code>int</code> <p>The start block to animate. Defaults to 0.</p> <code>0</code> <code>n_blocks</code> <code>int</code> <p>number of blocks to animate. Defaults to None. When None, animate all blocks after <code>start_block</code>.</p> <code>None</code> <p>Returns:     ani: matplotlib animation object</p> Source code in <code>src/bloqade/qbraid/simulation_result.py</code> <pre><code>def animate(\n    self,\n    dilation_rate: float = 0.05,\n    fps: int = 30,\n    gate_display_dilation: float = 1.0,\n    save_mpeg: bool = False,\n    filename: str = \"vqpu_animation\",\n    start_block: int = 0,\n    n_blocks: Optional[int] = None,\n):\n    \"\"\"animate the qpu state\n\n    Args:\n        dilation_rate (float): Conversion factor from the qpu time to animation time units. when dilation_rate=1.0, 1 (us) of qpu exec time corresponds to 1 second of animation time.\n        fps (int, optional): frame per second. Defaults to 30.\n        gate_display_dilation (float, optional): relative dilation rate of a gate event. Defaults to 1. When setting higher value, the gate event will be displayed longer.\n        save_mpeg (bool, optional): Save as mpeg. Defaults to False.\n        filename (str, optional): The file name of saved mpeg file. Defaults to \"vqpu_animation\". When `save_mpeg` is False, this argument is ignored.\n        start_block (int, optional): The start block to animate. Defaults to 0.\n        n_blocks (int, optional): number of blocks to animate. Defaults to None. When None, animate all blocks after `start_block`.\n    Returns:\n        ani: matplotlib animation object\n    \"\"\"\n    from bloqade.visual.animation.animate import animate_qpu_state\n\n    ani = animate_qpu_state(\n        state=self.atom_animation_state,\n        dilation_rate=dilation_rate,\n        fps=fps,\n        gate_display_dilation=gate_display_dilation,\n        start_block=start_block,\n        n_blocks=n_blocks,\n        save_mpeg=save_mpeg,\n        filename=filename,\n    )\n    return ani\n</code></pre>"},{"location":"reference/bloqade/qbraid/simulation_result/#bloqade.qbraid.simulation_result.QuEraSimulationResult.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json: dict) -&gt; QuEraSimulationResult\n</code></pre> <p>deserialize the object from a JSON serializable dictionary.</p> Source code in <code>src/bloqade/qbraid/simulation_result.py</code> <pre><code>@classmethod\ndef from_json(cls, json: dict) -&gt; \"QuEraSimulationResult\":\n    \"\"\"deserialize the object from a JSON serializable dictionary.\"\"\"\n    flair_visual_version = json[\"flair_visual_version\"]\n    counts = json[\"counts\"]\n    logs = pd.read_csv(StringIO(json[\"logs\"]), index_col=0)\n    atom_animation_state = vis_qpustate.AnimateQPUState.from_json(\n        json[\"atom_animation_state\"]\n    )\n    noise_model = NoiseModel(**json[\"noise_model\"])\n\n    return cls(\n        flair_visual_version=flair_visual_version,\n        counts=counts,\n        logs=logs,\n        atom_animation_state=atom_animation_state,\n        noise_model=noise_model,\n    )\n</code></pre>"},{"location":"reference/bloqade/qbraid/simulation_result/#bloqade.qbraid.simulation_result.QuEraSimulationResult.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; Dict[str, Any]\n</code></pre> <p>Turn the object into a JSON serializable dictionary.</p> Source code in <code>src/bloqade/qbraid/simulation_result.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"Turn the object into a JSON serializable dictionary.\"\"\"\n    return {\n        \"flair_visual_version\": self.flair_visual_version,\n        \"counts\": self.counts,\n        \"logs\": self.logs.to_csv(),\n        \"atom_animation_state\": self.atom_animation_state.to_json(),\n        \"noise_model\": self.noise_model.model_dump(mode=\"json\"),\n    }\n</code></pre>"},{"location":"reference/bloqade/qbraid/target/","title":"Target","text":""},{"location":"reference/bloqade/qbraid/target/#bloqade.qbraid.target.qBraid","title":"qBraid","text":"<pre><code>qBraid(\n    *,\n    allow_parallel: bool = False,\n    allow_global: bool = False,\n    provider: QbraidProvider,\n    qelib1: bool = True\n)\n</code></pre> <p>qBraid target for Bloqade kernels.</p> <p>qBraid target that accepts a Bloqade kernel and submits the kernel to the QuEra simulator hosted on qBraid. A <code>QbraidJob</code> is obtainable that then lets you query the status of the submitted program on the simulator as well as obtain results.</p> <p>Parameters:</p> Name Type Description Default <code>allow_parallel</code> <code>bool</code> <p>Allow parallel gate in the resulting QASM2 AST. Defaults to <code>False</code>. In the case its False, and the input kernel uses parallel gates, they will get rewrite into uop gates.</p> <code>False</code> <code>allow_global</code> <code>bool</code> <p>Allow global gate in the resulting QASM2 AST. Defaults to <code>False</code>. In the case its False, and the input kernel uses global gates, they will get rewrite into parallel gates. If both <code>allow_parallel</code> and <code>allow_global</code> are False, the input kernel will be rewritten to use uop gates.</p> <code>False</code> <code>provider</code> <code>QbraidProvider</code> <p>Qbraid-provided object to allow submission of the kernel to the QuEra simulator.</p> required <code>qelib1</code> <code>bool</code> <p>Include the <code>include \"qelib1.inc\"</code> line in the resulting QASM2 AST that's submitted to qBraid. Defaults to <code>True</code>.</p> <code>True</code> Source code in <code>src/bloqade/qbraid/target.py</code> <pre><code>def __init__(\n    self,\n    *,\n    allow_parallel: bool = False,\n    allow_global: bool = False,\n    provider: \"QbraidProvider\",  # inject externally for easier mocking\n    qelib1: bool = True,\n) -&gt; None:\n    \"\"\"Initialize the qBraid target.\n\n    Args:\n        allow_parallel (bool):\n            Allow parallel gate in the resulting QASM2 AST. Defaults to `False`.\n            In the case its False, and the input kernel uses parallel gates, they will get rewrite into uop gates.\n\n        allow_global (bool):\n            Allow global gate in the resulting QASM2 AST. Defaults to `False`.\n            In the case its False, and the input kernel uses global gates, they will get rewrite into parallel gates.\n            If both `allow_parallel` and `allow_global` are False, the input kernel will be rewritten to use uop gates.\n\n        provider (QbraidProvider):\n            Qbraid-provided object to allow submission of the kernel to the QuEra simulator.\n        qelib1 (bool):\n            Include the `include \"qelib1.inc\"` line in the resulting QASM2 AST that's\n            submitted to qBraid. Defaults to `True`.\n    \"\"\"\n\n    self.qelib1 = qelib1\n    self.provider = provider\n    self.allow_parallel = allow_parallel\n    self.allow_global = allow_global\n</code></pre>"},{"location":"reference/bloqade/qbraid/target/#bloqade.qbraid.target.qBraid.emit","title":"emit","text":"<pre><code>emit(\n    method: Method,\n    shots: Optional[int] = None,\n    tags: Optional[dict[str, str]] = None,\n) -&gt; Union[QbraidJob, list[QbraidJob]]\n</code></pre> <p>Submit the Bloqade kernel to the QuEra simulator on qBraid.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>The kernel to submit to qBraid.</p> required <code>shots</code> <code>Optional[int]</code> <p>(Optional[int]): Number of times to run the kernel. Defaults to None.</p> <code>None</code> <code>tags</code> <code>Optional[dict[str, str]]</code> <p>(Optional[dict[str,str]]): A dictionary of tags to associate with the Job.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[QbraidJob, list[QbraidJob]]</code> <p>Union[QbraidJob, list[QbraidJob]]: An object you can query for the status of your submission as well as obtain simulator results from.</p> Source code in <code>src/bloqade/qbraid/target.py</code> <pre><code>def emit(\n    self,\n    method: ir.Method,\n    shots: Optional[int] = None,\n    tags: Optional[dict[str, str]] = None,\n) -&gt; Union[\"QbraidJob\", list[\"QbraidJob\"]]:\n    \"\"\"Submit the Bloqade kernel to the QuEra simulator on qBraid.\n\n    Args:\n        method (ir.Method):\n            The kernel to submit to qBraid.\n        shots: (Optional[int]):\n            Number of times to run the kernel. Defaults to None.\n        tags: (Optional[dict[str,str]]):\n            A dictionary of tags to associate with the Job.\n\n    Returns:\n        Union[QbraidJob, list[QbraidJob]]:\n            An object you can query for the status of your submission as well as\n            obtain simulator results from.\n    \"\"\"\n\n    # Convert method to QASM2 string\n    qasm2_emitter = QASM2(\n        allow_parallel=self.allow_parallel,\n        allow_global=self.allow_global,\n        qelib1=self.qelib1,\n    )\n    qasm2_prog = qasm2_emitter.emit_str(method)\n\n    # Submit the QASM2 string to the qBraid simulator\n    quera_qasm_simulator = self.provider.get_device(\"quera_qasm_simulator\")\n\n    return quera_qasm_simulator.run(qasm2_prog, shots=shots, tags=tags)\n</code></pre>"},{"location":"reference/bloqade/squin/","title":"Index","text":""},{"location":"reference/bloqade/squin/groups/","title":"Groups","text":""},{"location":"reference/bloqade/squin/qubit/","title":"Qubit","text":"<p>qubit dialect for squin language.</p> <p>This dialect defines the operations that can be performed on qubits.</p> <p>Depends on: - <code>bloqade.squin.op</code>: provides the <code>OpType</code> type and semantics for operators applied to qubits. - <code>kirin.dialects.ilist</code>: provides the <code>ilist.IListType</code> type for lists of qubits.</p>"},{"location":"reference/bloqade/squin/qubit/#bloqade.squin.qubit.apply","title":"apply","text":"<pre><code>apply(\n    operator: Op, qubits: IList[Qubit, Any] | list[Qubit]\n) -&gt; None\n</code></pre> <p>Apply an operator to a list of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>operator</code> <code>Op</code> <p>The operator to apply.</p> required <code>qubits</code> <code>IList[Qubit, Any] | list[Qubit]</code> <p>The list of qubits to apply the operator to. The size of the list must be inferable and match the number of qubits expected by the operator.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/bloqade/squin/qubit.py</code> <pre><code>@wraps(Apply)\ndef apply(operator: Op, qubits: ilist.IList[Qubit, Any] | list[Qubit]) -&gt; None:\n    \"\"\"Apply an operator to a list of qubits.\n\n    Args:\n        operator: The operator to apply.\n        qubits: The list of qubits to apply the operator to. The size of the list\n            must be inferable and match the number of qubits expected by the operator.\n\n    Returns:\n        None\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/squin/qubit/#bloqade.squin.qubit.measure","title":"measure","text":"<pre><code>measure(qubits: IList[Qubit, Any]) -&gt; int\n</code></pre> <p>Measure the qubits in the list.\"</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>The list of qubits to measure.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The result of the measurement.</p> Source code in <code>src/bloqade/squin/qubit.py</code> <pre><code>@wraps(Measure)\ndef measure(qubits: ilist.IList[Qubit, Any]) -&gt; int:\n    \"\"\"Measure the qubits in the list.\"\n\n    Args:\n        qubits: The list of qubits to measure.\n\n    Returns:\n        int: The result of the measurement.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/squin/qubit/#bloqade.squin.qubit.measure_and_reset","title":"measure_and_reset","text":"<pre><code>measure_and_reset(qubits: IList[Qubit, Any]) -&gt; int\n</code></pre> <p>Measure the qubits in the list and reset them.\"</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>The list of qubits to measure and reset.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The result of the measurement.</p> Source code in <code>src/bloqade/squin/qubit.py</code> <pre><code>@wraps(MeasureAndReset)\ndef measure_and_reset(qubits: ilist.IList[Qubit, Any]) -&gt; int:\n    \"\"\"Measure the qubits in the list and reset them.\"\n\n    Args:\n        qubits: The list of qubits to measure and reset.\n\n    Returns:\n        int: The result of the measurement.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/squin/qubit/#bloqade.squin.qubit.new","title":"new","text":"<pre><code>new(n_qubits: int) -&gt; ilist.IList[Qubit, Any]\n</code></pre> <p>Create a new list of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>n_qubits(int)</code> <p>The number of qubits to create.</p> required <p>Returns:</p> Type Description <code>IList[Qubit, Any]</code> <p>(ilist.IList[Qubit, n_qubits]) A list of qubits.</p> Source code in <code>src/bloqade/squin/qubit.py</code> <pre><code>@wraps(New)\ndef new(n_qubits: int) -&gt; ilist.IList[Qubit, Any]:\n    \"\"\"Create a new list of qubits.\n\n    Args:\n        n_qubits(int): The number of qubits to create.\n\n    Returns:\n        (ilist.IList[Qubit, n_qubits]) A list of qubits.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/squin/qubit/#bloqade.squin.qubit.reset","title":"reset","text":"<pre><code>reset(qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Reset the qubits in the list.\"</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>The list of qubits to reset.</p> required Source code in <code>src/bloqade/squin/qubit.py</code> <pre><code>@wraps(Reset)\ndef reset(qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Reset the qubits in the list.\"\n\n    Args:\n        qubits: The list of qubits to reset.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/squin/wire/","title":"Wire","text":"<p>A NVIDIA QUAKE-like wire dialect.</p> <p>This dialect is expected to be used in combination with the operator dialect as an intermediate representation for analysis and optimization of quantum circuits. Thus we do not define wrapping functions for the statements in this dialect.</p>"},{"location":"reference/bloqade/squin/analysis/","title":"Index","text":""},{"location":"reference/bloqade/squin/analysis/schedule/","title":"Schedule","text":""},{"location":"reference/bloqade/squin/analysis/schedule/#bloqade.squin.analysis.schedule.StmtDag","title":"StmtDag  <code>dataclass</code>","text":"<pre><code>StmtDag(\n    id_table: IdTable[\n        Statement\n    ] = lambda: idtable.IdTable()(),\n    stmts: Dict[str, Statement] = OrderedDict(),\n    out_edges: Dict[str, Set[str]] = OrderedDict(),\n    inc_edges: Dict[str, Set[str]] = OrderedDict(),\n    stmt_index: Dict[Statement, int] = OrderedDict(),\n)\n</code></pre> <p>               Bases: <code>Graph[Statement]</code></p>"},{"location":"reference/bloqade/squin/analysis/schedule/#bloqade.squin.analysis.schedule.StmtDag.topological_groups","title":"topological_groups","text":"<pre><code>topological_groups()\n</code></pre> <p>Split the dag into topological groups where each group contains nodes that have no dependencies on each other, but have dependencies on nodes in one or more previous groups.</p> <p>Yields:</p> Type Description <p>List[str]: A list of node ids in a topological group</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a cyclic dependency is detected</p> <p>The idea is to yield all nodes with no dependencies, then remove those nodes from the graph repeating until no nodes are left or we reach some upper limit. Worse case is a linear dag, so we can use len(dag.stmts) as the upper limit</p> <p>If we reach the limit and there are still nodes left, then we have a cyclic dependency.</p> Source code in <code>src/bloqade/squin/analysis/schedule.py</code> <pre><code>def topological_groups(self):\n    \"\"\"Split the dag into topological groups where each group\n    contains nodes that have no dependencies on each other, but\n    have dependencies on nodes in one or more previous groups.\n\n    Yields:\n        List[str]: A list of node ids in a topological group\n\n\n    Raises:\n        ValueError: If a cyclic dependency is detected\n\n\n    The idea is to yield all nodes with no dependencies, then remove\n    those nodes from the graph repeating until no nodes are left\n    or we reach some upper limit. Worse case is a linear dag,\n    so we can use len(dag.stmts) as the upper limit\n\n    If we reach the limit and there are still nodes left, then we\n    have a cyclic dependency.\n    \"\"\"\n\n    inc_edges = {k: set(v) for k, v in self.inc_edges.items()}\n\n    check_next = inc_edges.keys()\n\n    for _ in range(len(self.stmts)):\n        if len(inc_edges) == 0:\n            break\n\n        group = [node_id for node_id in check_next if len(inc_edges[node_id]) == 0]\n        yield group\n\n        check_next = set()\n        for n in group:\n            inc_edges.pop(n)\n            for m in self.out_edges[n]:\n                check_next.add(m)\n                inc_edges[m].remove(n)\n\n    if inc_edges:\n        raise ValueError(\"Cyclic dependency detected\")\n</code></pre>"},{"location":"reference/bloqade/squin/analysis/nsites/","title":"Index","text":""},{"location":"reference/bloqade/squin/analysis/nsites/analysis/","title":"Analysis","text":""},{"location":"reference/bloqade/squin/analysis/nsites/impls/","title":"Impls","text":""},{"location":"reference/bloqade/squin/analysis/nsites/lattice/","title":"Lattice","text":""},{"location":"reference/bloqade/squin/op/","title":"Index","text":""},{"location":"reference/bloqade/squin/op/#bloqade.squin.op.ch","title":"ch","text":"<pre><code>ch() -&gt; types.Op\n</code></pre> <p>Control H gate.</p> Source code in <code>src/bloqade/squin/op/__init__.py</code> <pre><code>@op\ndef ch() -&gt; types.Op:\n    \"\"\"Control H gate.\"\"\"\n    return control(h(), n_controls=1)\n</code></pre>"},{"location":"reference/bloqade/squin/op/#bloqade.squin.op.cphase","title":"cphase","text":"<pre><code>cphase(theta: float) -&gt; types.Op\n</code></pre> <p>Control Phase gate.</p> Source code in <code>src/bloqade/squin/op/__init__.py</code> <pre><code>@op\ndef cphase(theta: float) -&gt; types.Op:\n    \"\"\"Control Phase gate.\"\"\"\n    return control(phase(theta), n_controls=1)\n</code></pre>"},{"location":"reference/bloqade/squin/op/#bloqade.squin.op.cx","title":"cx","text":"<pre><code>cx() -&gt; types.Op\n</code></pre> <p>Controlled X gate.</p> Source code in <code>src/bloqade/squin/op/__init__.py</code> <pre><code>@op\ndef cx() -&gt; types.Op:\n    \"\"\"Controlled X gate.\"\"\"\n    return control(x(), n_controls=1)\n</code></pre>"},{"location":"reference/bloqade/squin/op/#bloqade.squin.op.cy","title":"cy","text":"<pre><code>cy() -&gt; types.Op\n</code></pre> <p>Controlled Y gate.</p> Source code in <code>src/bloqade/squin/op/__init__.py</code> <pre><code>@op\ndef cy() -&gt; types.Op:\n    \"\"\"Controlled Y gate.\"\"\"\n    return control(y(), n_controls=1)\n</code></pre>"},{"location":"reference/bloqade/squin/op/#bloqade.squin.op.cz","title":"cz","text":"<pre><code>cz() -&gt; types.Op\n</code></pre> <p>Control Z gate.</p> Source code in <code>src/bloqade/squin/op/__init__.py</code> <pre><code>@op\ndef cz() -&gt; types.Op:\n    \"\"\"Control Z gate.\"\"\"\n    return control(z(), n_controls=1)\n</code></pre>"},{"location":"reference/bloqade/squin/op/#bloqade.squin.op.rx","title":"rx","text":"<pre><code>rx(theta: float) -&gt; types.Op\n</code></pre> <p>Rotation X gate.</p> Source code in <code>src/bloqade/squin/op/__init__.py</code> <pre><code>@op\ndef rx(theta: float) -&gt; types.Op:\n    \"\"\"Rotation X gate.\"\"\"\n    return rot(x(), theta)\n</code></pre>"},{"location":"reference/bloqade/squin/op/#bloqade.squin.op.ry","title":"ry","text":"<pre><code>ry(theta: float) -&gt; types.Op\n</code></pre> <p>Rotation Y gate.</p> Source code in <code>src/bloqade/squin/op/__init__.py</code> <pre><code>@op\ndef ry(theta: float) -&gt; types.Op:\n    \"\"\"Rotation Y gate.\"\"\"\n    return rot(y(), theta)\n</code></pre>"},{"location":"reference/bloqade/squin/op/#bloqade.squin.op.rz","title":"rz","text":"<pre><code>rz(theta: float) -&gt; types.Op\n</code></pre> <p>Rotation Z gate.</p> Source code in <code>src/bloqade/squin/op/__init__.py</code> <pre><code>@op\ndef rz(theta: float) -&gt; types.Op:\n    \"\"\"Rotation Z gate.\"\"\"\n    return rot(z(), theta)\n</code></pre>"},{"location":"reference/bloqade/squin/op/complex/","title":"Complex","text":""},{"location":"reference/bloqade/squin/op/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/squin/op/stmts/#bloqade.squin.op.stmts.P0","title":"P0","text":"<p>               Bases: <code>ConstantOp</code></p> <p>The \\(P_0\\) projection operator.</p> \\[ P0 = \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{bmatrix} \\]"},{"location":"reference/bloqade/squin/op/stmts/#bloqade.squin.op.stmts.P1","title":"P1","text":"<p>               Bases: <code>ConstantOp</code></p> <p>The \\(P_1\\) projection operator.</p> \\[ P1 = \\begin{bmatrix} 0 &amp; 0 \\\\ 0 &amp; 1 \\end{bmatrix} \\]"},{"location":"reference/bloqade/squin/op/stmts/#bloqade.squin.op.stmts.PhaseOp","title":"PhaseOp","text":"<p>               Bases: <code>PrimitiveOp</code></p> <p>A phase operator.</p> \\[ PhaseOp(theta) = e^{i       heta} I \\]"},{"location":"reference/bloqade/squin/op/stmts/#bloqade.squin.op.stmts.ShiftOp","title":"ShiftOp","text":"<p>               Bases: <code>PrimitiveOp</code></p> <p>A phase shift operator.</p> \\[ Shift(theta) = \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; e^{i \\theta} \\end{bmatrix} \\]"},{"location":"reference/bloqade/squin/op/stmts/#bloqade.squin.op.stmts.Sn","title":"Sn","text":"<p>               Bases: <code>ConstantOp</code></p> <p>\\(S_{-}\\) operator.</p> \\[ Sn = \\frac{1}{2} (S_x - i S_y) = \\frac{1}{2} \\begin{bmatrix} 0 &amp; 0 \\\\ 1 &amp; 0 \\end{bmatrix} \\]"},{"location":"reference/bloqade/squin/op/stmts/#bloqade.squin.op.stmts.Sp","title":"Sp","text":"<p>               Bases: <code>ConstantOp</code></p> <p>\\(S_{+}\\) operator.</p> \\[ Sp = \\frac{1}{2} (S_x + i S_y) = \\frac{1}{2}\\begin{bmatrix} 0 &amp; 1 \\\\ 0 &amp; 0 \\end{bmatrix} \\]"},{"location":"reference/bloqade/squin/op/traits/","title":"Traits","text":""},{"location":"reference/bloqade/squin/op/traits/#bloqade.squin.op.traits.HasSites","title":"HasSites  <code>dataclass</code>","text":"<pre><code>HasSites()\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>An operator with a <code>sites</code> attribute.</p>"},{"location":"reference/bloqade/squin/op/types/","title":"Types","text":""},{"location":"reference/bloqade/stim/","title":"Index","text":""},{"location":"reference/bloqade/stim/#bloqade.stim.ConstBool","title":"ConstBool","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstBool.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstBool.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: bool = attribute(Bool)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstFloat","title":"ConstFloat","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstFloat.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstFloat.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: float = attribute(Float)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstInt","title":"ConstInt","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant integer value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstInt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Int)\n</code></pre> <p>result (Int): The result value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstInt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: int = attribute(Int)\n</code></pre> <p>value (int): The constant integer value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstStr","title":"ConstStr","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant str value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstStr.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(String)\n</code></pre> <p>result (str): The result value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstStr.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: str = attribute(String)\n</code></pre> <p>value (str): The constant str value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.Neg","title":"Neg","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a negation operation.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.PPMeasurement","title":"PPMeasurement","text":"<p>               Bases: <code>Statement</code></p>"},{"location":"reference/bloqade/stim/#bloqade.stim.PPMeasurement.p","title":"p  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p: SSAValue = argument(Float)\n</code></pre> <p>probability of noise introduced by measurement. For example 0.01 means 1% the measurement will be flipped</p>"},{"location":"reference/bloqade/stim/groups/","title":"Groups","text":""},{"location":"reference/bloqade/stim/dialects/","title":"Index","text":""},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstBool","title":"ConstBool","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstBool.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstBool.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: bool = attribute(Bool)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstFloat","title":"ConstFloat","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstFloat.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstFloat.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: float = attribute(Float)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstInt","title":"ConstInt","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant integer value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstInt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Int)\n</code></pre> <p>result (Int): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstInt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: int = attribute(Int)\n</code></pre> <p>value (int): The constant integer value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstStr","title":"ConstStr","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant str value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstStr.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(String)\n</code></pre> <p>result (str): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstStr.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: str = attribute(String)\n</code></pre> <p>value (str): The constant str value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.Neg","title":"Neg","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a negation operation.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.PPMeasurement","title":"PPMeasurement","text":"<p>               Bases: <code>Statement</code></p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.PPMeasurement.p","title":"p  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p: SSAValue = argument(Float)\n</code></pre> <p>probability of noise introduced by measurement. For example 0.01 means 1% the measurement will be flipped</p>"},{"location":"reference/bloqade/stim/dialects/aux/","title":"Index","text":""},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstBool","title":"ConstBool","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstBool.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstBool.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: bool = attribute(Bool)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstFloat","title":"ConstFloat","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstFloat.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstFloat.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: float = attribute(Float)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstInt","title":"ConstInt","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant integer value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstInt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Int)\n</code></pre> <p>result (Int): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstInt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: int = attribute(Int)\n</code></pre> <p>value (int): The constant integer value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstStr","title":"ConstStr","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant str value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstStr.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(String)\n</code></pre> <p>result (str): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstStr.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: str = attribute(String)\n</code></pre> <p>value (str): The constant str value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.Neg","title":"Neg","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a negation operation.</p>"},{"location":"reference/bloqade/stim/dialects/aux/emit/","title":"Emit","text":""},{"location":"reference/bloqade/stim/dialects/aux/interp/","title":"Interp","text":""},{"location":"reference/bloqade/stim/dialects/aux/lowering/","title":"Lowering","text":""},{"location":"reference/bloqade/stim/dialects/aux/types/","title":"Types","text":""},{"location":"reference/bloqade/stim/dialects/aux/stmts/","title":"Index","text":""},{"location":"reference/bloqade/stim/dialects/aux/stmts/annotate/","title":"Annotate","text":""},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/","title":"Const","text":""},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstBool","title":"ConstBool","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstBool.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstBool.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: bool = attribute(Bool)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstFloat","title":"ConstFloat","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstFloat.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstFloat.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: float = attribute(Float)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstInt","title":"ConstInt","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant integer value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstInt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Int)\n</code></pre> <p>result (Int): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstInt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: int = attribute(Int)\n</code></pre> <p>value (int): The constant integer value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstStr","title":"ConstStr","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant str value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstStr.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(String)\n</code></pre> <p>result (str): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstStr.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: str = attribute(String)\n</code></pre> <p>value (str): The constant str value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.Neg","title":"Neg","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a negation operation.</p>"},{"location":"reference/bloqade/stim/dialects/collapse/","title":"Index","text":""},{"location":"reference/bloqade/stim/dialects/collapse/#bloqade.stim.dialects.collapse.PPMeasurement","title":"PPMeasurement","text":"<p>               Bases: <code>Statement</code></p>"},{"location":"reference/bloqade/stim/dialects/collapse/#bloqade.stim.dialects.collapse.PPMeasurement.p","title":"p  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p: SSAValue = argument(Float)\n</code></pre> <p>probability of noise introduced by measurement. For example 0.01 means 1% the measurement will be flipped</p>"},{"location":"reference/bloqade/stim/dialects/collapse/emit/","title":"Emit","text":""},{"location":"reference/bloqade/stim/dialects/collapse/stmts/","title":"Index","text":""},{"location":"reference/bloqade/stim/dialects/collapse/stmts/measure/","title":"Measure","text":""},{"location":"reference/bloqade/stim/dialects/collapse/stmts/measure/#bloqade.stim.dialects.collapse.stmts.measure.Measurement","title":"Measurement","text":"<p>               Bases: <code>Statement</code></p>"},{"location":"reference/bloqade/stim/dialects/collapse/stmts/measure/#bloqade.stim.dialects.collapse.stmts.measure.Measurement.p","title":"p  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p: SSAValue = argument(Float)\n</code></pre> <p>probability of noise introduced by measurement. For example 0.01 means 1% the measurement will be flipped</p>"},{"location":"reference/bloqade/stim/dialects/collapse/stmts/pp_measure/","title":"Pp measure","text":""},{"location":"reference/bloqade/stim/dialects/collapse/stmts/pp_measure/#bloqade.stim.dialects.collapse.stmts.pp_measure.PPMeasurement","title":"PPMeasurement","text":"<p>               Bases: <code>Statement</code></p>"},{"location":"reference/bloqade/stim/dialects/collapse/stmts/pp_measure/#bloqade.stim.dialects.collapse.stmts.pp_measure.PPMeasurement.p","title":"p  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p: SSAValue = argument(Float)\n</code></pre> <p>probability of noise introduced by measurement. For example 0.01 means 1% the measurement will be flipped</p>"},{"location":"reference/bloqade/stim/dialects/collapse/stmts/reset/","title":"Reset","text":""},{"location":"reference/bloqade/stim/dialects/gate/","title":"Index","text":""},{"location":"reference/bloqade/stim/dialects/gate/emit/","title":"Emit","text":""},{"location":"reference/bloqade/stim/dialects/gate/stmts/","title":"Index","text":""},{"location":"reference/bloqade/stim/dialects/gate/stmts/base/","title":"Base","text":""},{"location":"reference/bloqade/stim/dialects/gate/stmts/clifford_1q/","title":"Clifford 1q","text":""},{"location":"reference/bloqade/stim/dialects/gate/stmts/clifford_2q/","title":"Clifford 2q","text":""},{"location":"reference/bloqade/stim/dialects/gate/stmts/control_2q/","title":"Control 2q","text":""},{"location":"reference/bloqade/stim/dialects/gate/stmts/pp/","title":"Pp","text":""},{"location":"reference/bloqade/stim/dialects/noise/","title":"Index","text":""},{"location":"reference/bloqade/stim/dialects/noise/emit/","title":"Emit","text":""},{"location":"reference/bloqade/stim/dialects/noise/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/stim/emit/","title":"Index","text":""},{"location":"reference/bloqade/stim/emit/stim/","title":"Stim","text":""},{"location":"reference/bloqade/visual/","title":"Index","text":""},{"location":"reference/bloqade/visual/animation/","title":"Index","text":""},{"location":"reference/bloqade/visual/animation/animate/","title":"Animate","text":""},{"location":"reference/bloqade/visual/animation/animate/#bloqade.visual.animation.animate.animate_qpu_state","title":"animate_qpu_state","text":"<pre><code>animate_qpu_state(\n    state: QPUStateABC,\n    display_fov: Optional[FieldOfView] = None,\n    dilation_rate: float = 0.05,\n    fps: int = 30,\n    gate_display_dilation: float = 1.0,\n    fig_args={},\n    save_mpeg: bool = False,\n    filename: str = \"vqpu_animation\",\n    start_block: int = 0,\n    n_blocks: int | None = None,\n)\n</code></pre> <p>Generate an animation from the QPU state</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>QPUStateABC</code> <p>The QPU state to animate</p> required <code>display_fov</code> <code>Optional[FieldOfView]</code> <p>The field of view to display. Defaults to None. If None, it will use the QPU's field of view.</p> <code>None</code> <code>dilation_rate</code> <code>float</code> <p>The rate at which to dilate the time. Defaults to 0.05.</p> <code>0.05</code> <code>fps</code> <code>int</code> <p>The frames per second. Defaults to 30.</p> <code>30</code> <code>gate_display_dilation</code> <code>float</code> <p>The rate at which to dilate the gate display. Defaults to 1.0.</p> <code>1.0</code> <code>fig_args</code> <code>dict</code> <p>The arguments to pass to the matplotlib.pyplot.figure. Defaults to {}.</p> <code>{}</code> <code>save_mpeg</code> <code>bool</code> <p>Whether to save the animation as an mpeg. Defaults to False.</p> <code>False</code> <code>filename</code> <code>str</code> <p>The filename to save the mpeg as. Defaults to \"vqpu_animation\".</p> <code>'vqpu_animation'</code> <code>start_block</code> <code>int</code> <p>The block to start the animation at. Defaults to 0.</p> <code>0</code> <code>n_blocks</code> <code>int | None</code> <p>The number of blocks to animate. Defaults to None. If None, it will animate all blocks after <code>start_block</code>.</p> <code>None</code> Source code in <code>src/bloqade/visual/animation/animate.py</code> <pre><code>def animate_qpu_state(\n    state: QPUStateABC,\n    display_fov: Optional[FieldOfView] = None,\n    dilation_rate: float = 0.05,\n    fps: int = 30,\n    gate_display_dilation: float = 1.0,\n    fig_args={},\n    save_mpeg: bool = False,\n    filename: str = \"vqpu_animation\",\n    start_block: int = 0,\n    n_blocks: int | None = None,\n):\n    \"\"\"Generate an animation from the QPU state\n\n    Args:\n        state (QPUStateABC): The QPU state to animate\n        display_fov (Optional[FieldOfView], optional): The field of view to display. Defaults to None. If None, it will use the QPU's field of view.\n        dilation_rate (float, optional): The rate at which to dilate the time. Defaults to 0.05.\n        fps (int, optional): The frames per second. Defaults to 30.\n        gate_display_dilation (float, optional): The rate at which to dilate the gate display. Defaults to 1.0.\n        fig_args (dict, optional): The arguments to pass to the matplotlib.pyplot.figure. Defaults to {}.\n        save_mpeg (bool, optional): Whether to save the animation as an mpeg. Defaults to False.\n        filename (str, optional): The filename to save the mpeg as. Defaults to \"vqpu_animation\".\n        start_block (int, optional): The block to start the animation at. Defaults to 0.\n        n_blocks (int | None, optional): The number of blocks to animate. Defaults to None. If None, it will animate all blocks after `start_block`.\n\n    \"\"\"\n    qpu_fov = state.qpu_fov\n\n    if display_fov is None:\n        display_fov = qpu_fov\n\n    if start_block &gt;= len(state.block_durations) or start_block &lt; 0:\n        raise ValueError(\"Start block index is out of range\")\n\n    if n_blocks is None:\n        n_blocks = len(state.block_durations) - start_block\n\n    if n_blocks &lt; 0:\n        raise ValueError(\"Number of block to animate must be non-negative\")\n\n    slm_sites = state.get_slm_sites()\n\n    # Scale the figure to different screens and so that the number of SLM sites has the same\n    # \"area\" on screen\n    nsites = max([4, len(slm_sites)])\n    scale = (\n        np.sqrt(44.0 / nsites) * 2.0 * plt.rcParams[\"figure.dpi\"] / 100\n    )  # scale the size of the figure\n\n    # figure:\n    new_fig_args = {\"figsize\": (14, 8), **fig_args}\n    fig, mpl_axs = plt.subplot_mosaic(\n        mosaic=[[\"Reg\", \"Info\"], [\"Reg\", \"Gate\"], [\"Reg\", \"Gate\"]],\n        gridspec_kw={\"width_ratios\": [3, 1]},\n        **new_fig_args,\n    )\n\n    # mpl_axs[\"Reg\"].axis(\"equal\")  # Axis equal must come before axis limits\n    mpl_axs[\"Reg\"].set_xlim(left=display_fov.xmin, right=display_fov.xmax)\n    mpl_axs[\"Reg\"].set_ylim(bottom=display_fov.ymin, top=display_fov.ymax)\n    mpl_axs[\"Reg\"].set(xlabel=\"x (um)\", ylabel=\"y (um)\")\n    mpl_axs[\"Reg\"].set_aspect(\"equal\")\n\n    # slm:\n    slm_plt_arg = {\n        \"facecolors\": \"none\",\n        \"edgecolors\": \"k\",\n        \"linestyle\": \"-\",\n        \"s\": 80 * scale,\n        \"alpha\": 0.3,\n        \"linewidth\": 0.5 * np.sqrt(scale),\n    }\n    mpl_axs[\"Reg\"].scatter(\n        x=slm_sites[:, 0], y=slm_sites[:, 1], **slm_plt_arg\n    )  # this is statically generated, so it will be the background\n\n    # atoms:\n    reg_plt_arg = {\n        \"s\": 65 * scale,\n        \"marker\": \"o\",\n        \"facecolors\": quera_color_code.purple,\n        \"alpha\": 1.0,\n    }\n    reg_panel = mpl_axs[\"Reg\"]\n    reg_scat = reg_panel.scatter([], [], **reg_plt_arg)\n\n    # gates:\n    gp = GatePainter(mpl_ax=reg_panel, qpu_fov=qpu_fov, scale=scale)\n\n    # annotate_args = {\"fontsize\": 8, \"ha\": \"center\", \"alpha\": 0.7, \"color\": quera_color_code.yellow}\n    annotate_args = {\n        \"fontsize\": 6 * np.sqrt(scale),\n        \"ha\": \"center\",\n        \"va\": \"center\",\n        \"alpha\": 1.0,\n        \"color\": quera_color_code.yellow,\n        \"weight\": \"bold\",\n    }\n    reg_annot_list = [\n        reg_panel.annotate(f\"{i}\", atom_position, **annotate_args)\n        for i, atom_position in state.get_atoms_position(time=0.0, include_lost=False)\n    ]\n\n    # AODs:\n    aod_plot_args = {\n        \"s\": 260 * scale,\n        \"marker\": \"+\",\n        \"alpha\": 0.7,\n        \"facecolors\": quera_color_code.red,\n        \"zorder\": -100,\n        \"linewidth\": np.sqrt(scale),\n    }\n    aod_scat = reg_panel.scatter(x=[], y=[], **aod_plot_args)\n\n    aod_h_args = {\n        \"s\": 1e20,\n        \"marker\": \"|\",\n        \"alpha\": 1.0,\n        \"color\": \"#FFE8E9\",\n        \"zorder\": -101,\n        \"linewidth\": 0.5 * np.sqrt(scale),\n    }\n    aod_h_scat = reg_panel.scatter(x=[], y=[], **aod_h_args)\n    aod_v_args = {\n        \"s\": 1e20,\n        \"marker\": \"_\",\n        \"alpha\": 1.0,\n        \"color\": \"#FFE8E9\",\n        \"zorder\": -101,\n        \"linewidth\": 0.5 * np.sqrt(scale),\n    }\n    aod_v_scat = reg_panel.scatter(x=[], y=[], **aod_v_args)\n\n    ## Info Panel\n    info_text = mpl_axs[\"Info\"].text(x=0.05, y=0.5, s=\"\")\n    mpl_axs[\"Info\"].set_xticks([])\n    mpl_axs[\"Info\"].set_yticks([])\n    mpl_axs[\"Info\"].grid(False)\n\n    ## Event Panel:\n    log_text = mpl_axs[\"Gate\"].text(x=0.05, y=0.0, s=\"\", size=6)\n    mpl_axs[\"Gate\"].set_xticks([])\n    mpl_axs[\"Gate\"].set_yticks([])\n    mpl_axs[\"Gate\"].grid(False)\n\n    tstep_mv = 1.0 / (fps * dilation_rate)\n    tstep_gate = 1.0 / (fps * dilation_rate * gate_display_dilation)\n    blk_t_end = np.cumsum(state.block_durations)\n\n    # determine the dilation part of the timeline, and generate more frame\n    chunk_times = []\n    curr_t = 0 if start_block == 0 else blk_t_end[start_block - 1]\n\n    for glb_tstart_gate, duration in state.get_gate_events_timing():\n        if glb_tstart_gate &lt; curr_t:  # gate start before the current time\n            if glb_tstart_gate + duration &lt; curr_t:\n                continue\n        else:\n            dt = glb_tstart_gate - curr_t\n            chunk_times.append(np.linspace(curr_t, glb_tstart_gate, int(dt / tstep_mv)))\n            curr_t = glb_tstart_gate\n\n        t_gate_end = glb_tstart_gate + duration\n        dt = t_gate_end - curr_t\n        chunk_times.append(np.linspace(curr_t, t_gate_end, int(dt / tstep_gate)))\n        curr_t = t_gate_end\n\n    dt = blk_t_end[-1] - curr_t\n    chunk_times.append(np.linspace(curr_t, blk_t_end[-1], int(dt / tstep_mv)))\n\n    times = np.concatenate(chunk_times)\n\n    fig.tight_layout()\n    fig.subplots_adjust(wspace=0.1)\n\n    def _update_annotate(loc, idx, annotate_artist):\n        new_loc = (loc[0], loc[1] - 0.06)\n        annotate_artist.set_position(new_loc)\n        txt = f\"{idx}\"\n        annotate_artist.set_text(txt)\n        return loc\n\n    def update(frame: int, state: QPUStateABC, times: np.ndarray, blk_t_end: np.array):\n\n        # get positions:\n\n        blk_id = bisect.bisect_left(blk_t_end, times[frame])\n        lbl = f\"Block: [{blk_id}]\\n\"\n        lbl += f\"Block dur: {state.block_durations[blk_id]:.2f} us\\n\"\n        lbl += f\"Total elapsed time: {times[frame]:.2f} us\"\n        info_text.set_text(lbl)\n\n        # update atoms location and annotation\n        post = np.array(\n            [\n                _update_annotate(\n                    atom_position,\n                    i,\n                    reg_annot_list[i],\n                )\n                for i, atom_position in state.get_atoms_position(\n                    times[frame], include_lost=False\n                )\n            ]\n        )\n        post = post if post.size &gt; 0 else np.array([(None, None)])\n        reg_scat.set_offsets(post)\n\n        # update log event panels\n        lost_events = state.get_atoms_lost_info(times[frame])\n\n        # update log gate:\n        gate_events = state.get_gate_events(times[frame])\n        gate_events_log = [\n            f\"Gate: {gate.cls_name} @ {t:.6f} (us)\\n\"\n            for t, gate in state.get_gate_events(times[frame])\n        ]\n        log_text.set_text(\"\".join(lost_events) + \"\".join(gate_events_log))\n\n        gate_artists = gp.process_gates([gate for _, gate in gate_events])\n\n        # update AODs\n        post = state.sample_aod_traps(times[frame]) or [(None, None)]\n        aod_scat.set_offsets(post)\n        aod_v_scat.set_offsets(post)\n        aod_h_scat.set_offsets(post)\n\n        return (\n            [reg_scat, info_text, log_text, aod_scat, aod_v_scat, aod_h_scat]\n            + reg_annot_list\n            + gate_artists\n        )\n\n    ani = FuncAnimation(\n        fig=fig,\n        func=functools.partial(update, state=state, times=times, blk_t_end=blk_t_end),\n        frames=len(times),\n        interval=tstep_mv,\n        blit=True,\n        repeat=False,\n    )\n    if save_mpeg:\n        n_frame = len(times)\n        pbar = tqdm.tqdm(range(n_frame))\n\n        def p_call_back(i, total_n):\n            pbar.update()\n\n        ani.save(\n            f\"{filename}.mp4\", writer=\"ffmpeg\", fps=fps, progress_callback=p_call_back\n        )\n    else:\n        return ani\n</code></pre>"},{"location":"reference/bloqade/visual/animation/base/","title":"Base","text":""},{"location":"reference/bloqade/visual/animation/base/#bloqade.visual.animation.base.RowRegionGateArtist","title":"RowRegionGateArtist  <code>dataclass</code>","text":"<pre><code>RowRegionGateArtist(\n    mpl_ax: Any,\n    xmin,\n    width,\n    ymin,\n    ymin_keepout,\n    ymax,\n    ymax_keepout,\n    color,\n)\n</code></pre> <p>               Bases: <code>GateArtist</code></p> <p>A row region gate artist object.</p> <p>bound box is [y_origin - width/2, y_origin + width/2]</p> Source code in <code>src/bloqade/visual/animation/base.py</code> <pre><code>def __init__(\n    self, mpl_ax: Any, xmin, width, ymin, ymin_keepout, ymax, ymax_keepout, color\n):\n    super().__init__(mpl_ax)\n    self.width = width\n    self.xmin = xmin\n    rc_btm = mpatches.Rectangle(\n        [xmin, ymin_keepout],\n        width,\n        ymin - ymin_keepout,\n        color=color,\n        alpha=0.3,\n        visible=False,\n    )\n    mpl_ax.add_patch(rc_btm)\n    self.mpl_obj_keepout_btm = rc_btm\n\n    rc = mpatches.Rectangle(\n        [xmin, ymin], width, ymax - ymin, color=color, alpha=0.6, visible=False\n    )\n    mpl_ax.add_patch(rc)\n    self.mpl_obj = rc\n\n    rc_top = mpatches.Rectangle(\n        [xmin, ymax],\n        width,\n        ymax_keepout - ymax,\n        color=color,\n        alpha=0.3,\n        visible=False,\n    )\n    mpl_ax.add_patch(rc_top)\n    self.mpl_obj_keepout_top = rc_top\n</code></pre>"},{"location":"reference/bloqade/visual/animation/gate_event/","title":"Gate event","text":""},{"location":"reference/bloqade/visual/animation/runtime/","title":"Index","text":""},{"location":"reference/bloqade/visual/animation/runtime/aod/","title":"Aod","text":""},{"location":"reference/bloqade/visual/animation/runtime/atoms/","title":"Atoms","text":""},{"location":"reference/bloqade/visual/animation/runtime/ppoly/","title":"Ppoly","text":""},{"location":"reference/bloqade/visual/animation/runtime/qpustate/","title":"Qpustate","text":""},{"location":"reference/bloqade/visual/animation/runtime/utils/","title":"Utils","text":""},{"location":"scripts/gen_ref_nav/","title":"Gen ref nav","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"Generate the code reference pages and navigation.\"\"\"\n</pre> \"\"\"Generate the code reference pages and navigation.\"\"\" In\u00a0[\u00a0]: Copied! <pre>from pathlib import Path\n</pre> from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[\u00a0]: Copied! <pre>SRC_PATH = \"src\"\n</pre> SRC_PATH = \"src\" In\u00a0[\u00a0]: Copied! <pre>skip_keywords = [\n    \"julia\",  ## [KHW] skip for now since we didn't have julia codegen rdy\n    \"builder/base\",  ## hiding from user\n    \"builder/terminate\",  ## hiding from user\n    \"ir/tree_print\",  ## hiding from user\n    \"ir/visitor\",  ## hiding from user\n    \"codegen/\",  ## hiding from user\n    \"builder/factory\",  ## hiding from user\n    \"builder_old\",  ## deprecated from user\n    \"task_old\",  ## deprecated from user\n    \"visualization\",  ## hiding from user\n    \"submission/capabilities\",  ## hiding from user\n    \"submission/quera_api_client\",\n]\n</pre> skip_keywords = [     \"julia\",  ## [KHW] skip for now since we didn't have julia codegen rdy     \"builder/base\",  ## hiding from user     \"builder/terminate\",  ## hiding from user     \"ir/tree_print\",  ## hiding from user     \"ir/visitor\",  ## hiding from user     \"codegen/\",  ## hiding from user     \"builder/factory\",  ## hiding from user     \"builder_old\",  ## deprecated from user     \"task_old\",  ## deprecated from user     \"visualization\",  ## hiding from user     \"submission/capabilities\",  ## hiding from user     \"submission/quera_api_client\", ] In\u00a0[\u00a0]: Copied! <pre>nav = mkdocs_gen_files.Nav()\nfor path in sorted(Path(SRC_PATH).rglob(\"*.py\")):\n    module_path = path.relative_to(SRC_PATH).with_suffix(\"\")\n    doc_path = path.relative_to(SRC_PATH).with_suffix(\".md\")\n    full_doc_path = Path(\"reference\", doc_path)\n\n    iskip = False\n\n    for kwrd in skip_keywords:\n        if kwrd in str(doc_path):\n            iskip = True\n            break\n    if iskip:\n        print(\"[Ignore]\", str(doc_path))\n        continue\n\n    print(\"[&gt;]\", str(doc_path))\n\n    parts = tuple(module_path.parts)\n\n    if parts[-1] == \"__init__\":\n        parts = parts[:-1]\n        doc_path = doc_path.with_name(\"index.md\")\n        full_doc_path = full_doc_path.with_name(\"index.md\")\n    elif parts[-1].startswith(\"_\"):\n        continue\n\n    nav[parts] = doc_path.as_posix()\n    with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:\n        ident = \".\".join(parts)\n        fd.write(f\"::: {ident}\")\n\n    mkdocs_gen_files.set_edit_path(full_doc_path, \"..\" / path)\n</pre> nav = mkdocs_gen_files.Nav() for path in sorted(Path(SRC_PATH).rglob(\"*.py\")):     module_path = path.relative_to(SRC_PATH).with_suffix(\"\")     doc_path = path.relative_to(SRC_PATH).with_suffix(\".md\")     full_doc_path = Path(\"reference\", doc_path)      iskip = False      for kwrd in skip_keywords:         if kwrd in str(doc_path):             iskip = True             break     if iskip:         print(\"[Ignore]\", str(doc_path))         continue      print(\"[&gt;]\", str(doc_path))      parts = tuple(module_path.parts)      if parts[-1] == \"__init__\":         parts = parts[:-1]         doc_path = doc_path.with_name(\"index.md\")         full_doc_path = full_doc_path.with_name(\"index.md\")     elif parts[-1].startswith(\"_\"):         continue      nav[parts] = doc_path.as_posix()     with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:         ident = \".\".join(parts)         fd.write(f\"::: {ident}\")      mkdocs_gen_files.set_edit_path(full_doc_path, \"..\" / path) In\u00a0[\u00a0]: Copied! <pre>with mkdocs_gen_files.open(\"reference/SUMMARY.txt\", \"w\") as nav_file:\n    nav_file.writelines(nav.build_literate_nav())\n</pre> with mkdocs_gen_files.open(\"reference/SUMMARY.txt\", \"w\") as nav_file:     nav_file.writelines(nav.build_literate_nav())"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/archive/2023/","title":"2023","text":""}]}