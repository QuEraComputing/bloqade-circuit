from abc import ABC
from dataclasses import dataclass, field

from kirin import ir, emit, interp, idtable
from kirin.dialects import scf, func
from kirin.worklist import WorkList

from bloqade.qasm2.parse import ast
from bloqade.qasm2.types import QubitType
from bloqade.qasm2.dialects import parallel, glob, noise


@dataclass
class Frame(emit.EmitFrame[ast.Node | None]):
    ssa: idtable.IdTable[ir.SSAValue]
    body: list[ast.Statement] = field(default_factory=list)


@dataclass
class QASM2(emit.EmitABC[Frame, ast.Node | None], ABC):
    keys = ("emit.qasm2",)
    void = None

    # options
    prefix: str = field(default="", kw_only=True)
    prefix_if_none: str = field(default="var_", kw_only=True)

    # state
    callables: emit.julia.SymbolTable = field(init=False)
    worklist: WorkList[ir.Statement] = field(init=False)

    def initialize(self):
        super().initialize()
        self.callables = emit.julia.SymbolTable()
        self.worklist = WorkList()
        return self

    def initialize_frame(
        self, node: ir.Statement, *, has_parent_access: bool = False
    ) -> Frame:
        return Frame(
            node,
            ssa=idtable.IdTable[ir.SSAValue](
                prefix=self.prefix,
                prefix_if_none=self.prefix_if_none,
            ),
            has_parent_access=has_parent_access,
        )

    def run(self, node: ir.Method | ir.Statement):
        if isinstance(node, ir.Method):
            node = node.code

        if self.dialects.data.intersection(
            (parallel.dialect, glob.dialect, noise.dialect)
        ):
            header = ast.Kirin([dialect.name for dialect in self.dialects])
        else:
            header = ast.OPENQASM(ast.Version(2, 0))

        body = node.get_present_trait(ir.CallableStmtInterface).get_callable_region(
            node
        )
        with self.eval_context():
            block = body.blocks[0]
            with self.new_frame(node) as frame:
                frame.current_block = block
                frame.current_stmt = block.first_stmt
                if len(body.blocks) != 1:
                    raise interp.InterpreterError(
                        "QASM2 does not support general control flow"
                    )

                for stmt in block.stmts:
                    if isinstance(stmt, func.ConstantNone):
                        continue
                    if isinstance(stmt, func.Return):
                        # QASM2 does not support return values
                        if not isinstance(stmt.value.owner, func.ConstantNone):
                            raise interp.InterpreterError(
                                "QASM2 does not support return values, kernel must return None"
                            )
                        break

                    ret = self.frame_eval(frame, stmt)
                    if isinstance(ret, tuple):
                        frame.set_values(stmt.results, ret)
                    elif ret is not None:
                        raise interp.InterpreterError(
                            f"QASM2 does not support return values or general control flows: {ret}"
                        )

                code = ast.MainProgram(header=header, statements=frame.body)

                while self.worklist:
                    callable = self.worklist.pop()
                    if callable is None:
                        break

                    _, gate = self.eval(callable)
                    if isinstance(gate, tuple) and isinstance(gate[0], ast.Gate):
                        code.statements.insert(0, gate[0])  # insert at the beginning
                    else:
                        raise interp.InterpreterError(
                            f"invalid result generated by {callable}: {gate}"
                        )
                
                return code


@func.dialect.register(key="emit.qasm2")
class Func(interp.MethodTable):

    @interp.impl(func.Function)
    def emit_func(
        self,
        emit: QASM2,
        frame: Frame,
        stmt: func.Function,
    ):
        args: list[ast.Node] = []
        cparams, qparams = [], []
        for arg in stmt.body.blocks[0].args:
            assert arg.name is not None

            args.append(ast.Name(id=arg.name))
            if arg.type.is_subseteq(QubitType):
                qparams.append(arg.name)
            else:
                cparams.append(arg.name)

        if len(stmt.body.blocks) != 1:
            raise interp.InterpreterError(
                f"Gate function {stmt.name} must have exactly one block"
            )

        block = stmt.body.blocks[0]
        with emit.new_frame(stmt) as frame:
            for node in block.stmts:
                if isinstance(node, func.ConstantNone):
                    continue

                # NOTE: this is a single block if we see a return
                # statement, we break. In QASM2 return can only
                # be return None when used as a gate function
                if isinstance(node, func.Return):
                    break

                ret = emit.frame_eval(frame, node)
                if isinstance(ret, tuple):
                    frame.set_values(node.results, ret)
                elif ret is not None:
                    raise interp.InterpreterError(
                        "QASM2 does not support return values or general control flows"
                    )

        return (
            ast.Gate(
                name=stmt.sym_name, cparams=cparams, qparams=qparams, body=frame.body
            ),
        )


@scf.dialect.register(key="emit.qasm2")
class Scf(interp.MethodTable):

    @interp.impl(scf.IfElse)
    def emit_if_else(
        self,
        emit: QASM2,
        frame: Frame,
        stmt: scf.IfElse,
    ):
        assert (
            len(stmt.then_body.blocks) == 1
        ), "QASM2 if can only have a single statement"
        block = stmt.then_body.blocks[0]
        first_stmt = block.first_stmt
        last_stmt = block.last_stmt
        assert (
            first_stmt is not None and len(block.stmts) == 2
        ), "QASM2 if can only have a single statement"
        assert (
            isinstance(last_stmt, scf.Yield) and not last_stmt.values
        ), "QASM2 if can only have a single gate statement"
        assert len(stmt.else_body.blocks) == 0, "QASM2 if does not support else"

        with emit.new_frame(stmt) as body_frame:
            emit.frame_eval(body_frame, first_stmt)

        frame.body.append(
            ast.IfStmt(cond=frame.get_typed(stmt.cond, ast.Cmp), body=body_frame.body)
        )
        return
