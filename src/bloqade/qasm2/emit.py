from abc import ABC
from dataclasses import dataclass, field

from kirin import ir, emit, interp, idtable
from kirin.worklist import WorkList

from bloqade.qasm2.parse import ast
from bloqade.qasm2.dialects import parallel, glob, noise


@dataclass
class Frame(emit.EmitFrame[ast.Node | None]):
    ssa: idtable.IdTable[ir.SSAValue]
    body: list[ast.Statement] = field(default_factory=list)


@dataclass
class QASM2(emit.EmitABC[Frame, ast.Node | None], ABC):
    void = None

    # options
    prefix: str = field(default="", kw_only=True)
    prefix_if_none: str = field(default="var_", kw_only=True)

    # state
    callables: emit.julia.SymbolTable = field(init=False)
    worklist: WorkList[ir.Statement] = field(init=False)

    def initialize_frame(
        self, node: ir.Statement, *, has_parent_access: bool = False
    ) -> Frame:
        return Frame(
            node,
            ssa=idtable.IdTable[ir.SSAValue](
                prefix=self.prefix,
                prefix_if_none=self.prefix_if_none,
            ),
            has_parent_access=has_parent_access,
        )

    def run(self, node: ir.Method | ir.Statement):
        if isinstance(node, ir.Method):
            node = node.code

        if self.dialects.data.intersection(
            (parallel.dialect, glob.dialect, noise.dialect)
        ):
            header = ast.Kirin([dialect.name for dialect in self.dialects])
        else:
            header = ast.OPENQASM(ast.Version(2, 0))

        body = node.get_present_trait(ir.CallableStmtInterface).get_callable_region(
            node
        )
        with self.eval_context():
            block = body.blocks[0]
            with self.new_frame(node) as frame:
                frame.current_block = block
                frame.current_stmt = block.first_stmt
                if len(body.blocks) > 1:
                    raise interp.InterpreterError(
                        "QASM2 does not support general control flow"
                    )

                for stmt in block.stmts:
                    ret = self.frame_eval(frame, stmt)
                    if isinstance(ret, tuple):
                        frame.set_values(stmt.args, ret)
                    elif ret is not None:
                        raise interp.InterpreterError(
                            f"QASM2 does not support return values or general control flows: {ret}"
                        )

                code = ast.MainProgram(header=header, statements=frame.body)

                while self.worklist:
                    callable = self.worklist.pop()
                    if callable is None:
                        break

                    _, gate = self.eval(callable)
                    if isinstance(gate, tuple) and isinstance(gate[0], ast.Gate):
                        code.statements.insert(0, gate[0])  # insert at the beginning
                    else:
                        raise interp.InterpreterError(
                            f"invalid result generated by {callable}: {gate}"
                        )
