import abc
from typing import Any, Generic, TypeVar, ParamSpec
from dataclasses import dataclass

import numpy as np
from kirin import ir

Params = ParamSpec("Params")
RetType = TypeVar("RetType")


class Future(abc.ABC, Generic[RetType]):
    """Protocol for future objects that can be awaited."""

    @abc.abstractmethod
    def result(self, timeout: float | None) -> RetType:
        """Returns the result of the future, blocking until it is available or the timeout expires."""

    def cancel(self):
        """Attempts to cancel the execution of the future."""
        raise NotImplementedError(
            f"cancel method not implemented for {self.__class__.__name__}"
        )

    def cancelled(self) -> bool:
        """Returns True if the future was cancelled, False otherwise."""
        raise NotImplementedError(
            f"cancelled method not implemented for {self.__class__.__name__}"
        )

    def done(self) -> bool:
        """Returns True if the future is done, False otherwise."""
        raise NotImplementedError(
            f"done method not implemented for {self.__class__.__name__}"
        )


@dataclass
class AbstractTask(abc.ABC, Generic[Params, RetType]):
    kernel: ir.Method[Params, RetType]
    args: tuple[Any, ...]
    kwargs: dict[str, Any]

    @abc.abstractmethod
    def run(self, *args: Any, **kwargs: Any) -> RetType:
        """Executes the kernel and returns the result."""


@dataclass
class RemoteTask(AbstractTask[Params, RetType]):
    """Base class for tasks generated by the devices."""

    def run(self, *, shots: int = 1, timeout: float | None = None) -> RetType:
        return self.run_async(shots=shots).result(timeout=timeout)

    @abc.abstractmethod
    def run_async(self, *, shots: int = 1) -> Future[RetType]:
        """Executes the kernel asynchronously and returns a Future object."""

    ObsType = TypeVar("ObsType")

    def expect(
        self, observable: ir.Method[[RetType], ObsType], *, shots: int
    ) -> ObsType:
        """Returns the expectation value of the given observable after running the task."""
        raise NotImplementedError(
            f"expect method not implemented for {self.__class__.__name__}"
        )


@dataclass
class SimulatorTask(AbstractTask[Params, RetType]):
    """Base class for tasks generated by local simulators."""

    @abc.abstractmethod
    def run(self) -> RetType:
        """Executes the kernel and returns the result."""

    def rdm(self) -> np.ndarray:
        """Executes the kernel and returns the reduced density matrix of the result if the kernel returns a list of qubits."""
        raise NotImplementedError(
            f"rdm method not implemented for {self.__class__.__name__}"
        )

    ObsType = TypeVar("ObsType")

    def expect(self, observable: ir.Method[[RetType], ObsType]) -> ObsType:
        """Returns the expectation value of the given observable after running the task."""
        raise NotImplementedError(
            f"expect method not implemented for {self.__class__.__name__}"
        )
